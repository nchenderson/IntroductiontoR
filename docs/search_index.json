[["intro.html", "An Introduction to R programming Chapter 1 Getting Started 1.1 Using R as a calculator 1.2 Variables in R 1.3 Rules for choosing variable names in R 1.4 Examples of valid and invalid variable names in R 1.5 Variable Assignment 1.6 Types of variables 1.7 R Operations with numbers 1.8 Exercises", " An Introduction to R programming Nicholas Henderson 2022-09-04 Chapter 1 Getting Started 1.1 Using R as a calculator You can use R as a basic calculator. For example, if we just type in 42 + 17 into the R console, it should print out the sum: 42 + 17 ## [1] 59 We can compute the square root of 243, \\(1.56^{124}\\), and \\(7.21 \\times 8^{4}\\), just by typing these expressions into the R console sqrt(243) ## [1] 15.58846 1.56*124 ## [1] 193.44 7.21*8^4 ## [1] 29532.16 1.2 Variables in R When working with more complicated mathematical operations in R, it is often useful to store intermediate values in named variables. For example, x &lt;- (42 + 17)*sqrt(43) y &lt;- 7.21*8^4 + log(2.34) z &lt;- x/y z ## print out the value of z ## [1] 0.01310022 Here, x, y, and z are examples of variables. The pair of characters &lt;- used together is known as the assignment operator in R. x &lt;- 2 assigns the value 2 to the variable x. A variable is the named storage of a value (or an object) in memory. Why do we need variables? To reuse the same value later on. To generalize an expression to use in many cases. How to use variables in R? To set the value of a variable, use assignment operator &lt;- To use the value, simply use the variable name as if it were its stored value. For example, … 1.3 Rules for choosing variable names in R Variables can be named however you want as long as you follow the several variable-naming rules that R has. In R variable names can include the following: letters: A-Z a-z digits: 0-9 underscore and period: _ . Additional rules: Variable names must start with letters or a period (not underscore or digits) If a variable name starts with a period, it cannot be followed by a number. Variable names are case sensitive. 1.4 Examples of valid and invalid variable names in R Valid Invalid i 2things my_variable location@ answer42 _user.name .name .3rd While you are free to choose variable names however you like as long as you follow the variable-naming rules of R, making variable names descriptive is highly recommended. Descriptive variable names make it easier to read code. This is very helpful if: You are sharing your code or Looking back at code you wrote many weeks/months ago Using a consistent convention for naming variables is recommended, too: https://r4ds.had.co.nz/workflow-basics.html 1.5 Variable Assignment Variables can be assigned using either &lt;- or = x = 123 # Use = to assign a variable y &lt;- 123 # Or use &lt;- to assign a variable x # Retrieve the value of x ## [1] 123 y # Retrieve the value of y ## [1] 123 The pair of characters &lt;- is the classic symbol used for variable assignment in R. The use of &lt;- instead of = is often recommended in R style guides: http://adv-r.had.co.nz/Style.html 1.5.1 &lt;- vs. = &lt;- and = will work the same if they are both used in the “usual way” (when assigning variables within or outside of a function). One exception, is when used inside a function call. For example, if we use = in the function sd(x): sd(x = c(1,2,3,4,5)) # only sets the argument x in sd(x) to (1,2,3,4,5) ## [1] 1.581139 #x ## will return an error if we try to print x sd(x &lt;- c(1,2,3,4,5)) # This actually assigns the vector (1,2,3,4,5) to x ## [1] 1.581139 x ## [1] 1 2 3 4 5 However, using something like sd(x &lt;- c(1,2,3,4,5)) where we assign variables in a function call is not really done that often. It is not common to assign variables in a function call (I never do it). Whenever, using a function f with a keyword such as x, you will generally want to call that function using f(x = ...) So, in my opinion, there is not really a strong reason to prefer using &lt;- over = for assignment. There are other justifications for using &lt;- such as the ability to do assignment from the left by using the reverse symbol -&gt; c(1, 2, 3, 4) -&gt; a # Using c(1,2,3,4) = a will not work! a ## [1] 1 2 3 4 1.6 Types of variables Variables can be used to store different types of values. Common types include numeric, text, and logical values. x &lt;- 3.2 x ## [1] 3.2 Here, x is actually a vector (basically a collection of elements storing the same type of data). It is a vector of length one (i.e., it only has one element). This is the reason why you see [1] printed out next to the number 3.2. This means that the first element of the vector x is \\(3.2\\). R treats every variable as some type of collection (e.g., vectors, matrices, lists, etc.). There are no separate data types in R for individual numbers. The elements in a vector can have different types (or modes). You can find the types of the elements in a vector by using the function typeof y &lt;- sqrt(1743) typeof(y) # double and integer are the two numeric types ## [1] &quot;double&quot; z &lt;- 3 # R automatically treats every number as double z ## [1] 3 typeof(z) ## [1] &quot;double&quot; The other common types for the elements in a vector include logical (TRUE or FALSE) values character basically text, e.g., “hello”, “car”, … y &lt;- TRUE typeof(y) ## [1] &quot;logical&quot; z &lt;- &quot;dog&quot; # to define a character variable, place it inside quotes typeof(z) ## [1] &quot;character&quot; We will discuss these types in more detail later on when we discuss vectors, matrices, and lists. 1.7 R Operations with numbers As we mentioned before, … Operator Meaning Example Result + addition 5 + 8 13 - subtraction 90 - 10 80 * multiplication 4 * 7 28 / division 7 / 2 3.5 %% remainder 7 %% 2 1 ^ exponent 3 ^ 4 81 ** exponent 3 ** 4 81 R operations with numbers have similar precedence rules to arithmetic operations Operator Description Precedence +, - addition and subtraction low *, /, %% multiplication, division, remainder … **, ^ exponentiation … (expressions…) Parenthesis high Examples of operation precedence can be seen when typing the following expressions into the R console: 1 + 2 *3 ^ 4 # power &gt; mult/div &gt; add/sub ## [1] 163 (1 + 2 ) *3 ^ 4 # parenthesis &gt; power ## [1] 243 1.8 Exercises Compute the number \\[\\begin{equation} \\frac{\\sqrt{1.43 + 5^{1.2}}}{3} \\end{equation}\\] directly in the R console. Write an R script that assigns the value … \\[\\begin{equation} \\ln\\Big( 1 + \\exp(-2^{1.4}) \\Big) + \\ln\\Big(1 + 2\\exp(3^{1.7}) \\Big) \\end{equation}\\] … to a variable named x and prints the result in the Console when you run the script. Which of the following is NOT a valid variable name in R? .independent_variable3 _independent_variable3 independent_variable3 independent.variable3 "],["ifelse.html", "Chapter 2 Logical Expressions and If-Else Statements in R 2.1 Logical Expression in R", " Chapter 2 Logical Expressions and If-Else Statements in R 2.1 Logical Expression in R A Logical expression is an expression that evaluates to either TRUE or FALSE. The following are examples of logical expressions in R: 4 &gt; 2 3 &lt;= 5 15.0 + 1.3*1.3 &gt; 17.0 \"cat\" == \"dog\" Each of the above expressions will evaluate to either TRUE or FALSE if you run them in R. 4 &gt; 2 ## [1] TRUE 3 &lt;= 5 ## [1] TRUE 15.0 + 1.3*1.3 &gt; 17.0 ## [1] FALSE x &lt;- &quot;cat&quot; == &quot;dog&quot; # assign to the variable x the value # returned by this logical expression x ## [1] FALSE Most logical expressions are constructed by using some combination of: Comparison operators (&lt;, &lt;=, ==, !=) Logical operators (and, or, not) (in R: &amp;&amp;, ||, !) 2.1.1 Comparison Operators Operator Meaning Example Result &lt; Less than 5 &lt; 3 FALSE &gt; Greater than 5 &gt; 3 TRUE &lt;= Less than or equal to 3 &lt;= 6 TRUE &gt;= Greater than or equal to 4 &gt;= 3 TRUE == Equal to 2 == 2 TRUE != Not equal to ‘str’ != ‘stR’ TRUE 2.1.2 Logical Operators The first main logical operator we will discuss is the logical AND In R, the logical operator &amp;&amp; is used to represent the logical AND The logical AND is used to test whether or not two statements are both true. For two logical expressions A and B, the logical expression A &amp;&amp; B is true only if both A and B evaluate to true. 4 &gt; 2 &amp;&amp; 5/2 == 1 ## only the first statement is TRUE ## [1] FALSE 4 &gt; 2 &amp;&amp; &quot;car&quot; == &quot;truck&quot; ## only the first statement is TRUE ## [1] FALSE 4 &gt; 2 &amp;&amp; 3 &lt; 5 ## both statements are TRUE ## [1] TRUE "],["functions.html", "Chapter 3 Functions in R 3.1 Built-in R functions 3.2 Construction your own R functions 3.3 Default argument values in functions 3.4 Specifying function arguments with keywords 3.5 Exercises", " Chapter 3 Functions in R A function in R can be thought of as a sequence of statements that takes some input, uses that input to compute something, and then returns a result. Why do we need functions? To modularize a task so that we can reuse the same code in many places. To increase readability of code. To reduce redundancy and reduce the number of errors. 3.1 Built-in R functions base R has many useful built-in functions that you can use. Other R packages are another source of useful functions. R’s base package is loaded by default. A few other packages including graphics, stats, and *utils are usually loaded by default as well. The base package includes many widely-used functions, such as the []print() or the sum() function. There are many other R packages available which contain many useful functions. 3.2 Construction your own R functions You can write your own functions as needed. While base R and the many available R packages have a wide range of useful functions, being able to write your own functions gives you much greater flexibility when working with R. 3.2.1 Function Definition Syntax There are three key components of a function definition in R. Function name: the name which will be used to call the function Function arguments: values to pass to a function as input. Return value: the value returned by a function as output. The general syntax for writing your own R function is: function_name &lt;- function(params){ ## function_name is the name of the function ## params name of the input variable within this function statement1 ## statements executed when the function is called statement2 ## statements convert params into some value to be ... ## returned return(return_value) ## return the variable return_value } 3.2.2 Example 1 Let’s write a function that takes a number as an input and returns the square of that number. ## define a new function named square square &lt;- function(x) { ## function name: square, argument : x return(x*x) ## returns x*x } square(10) ## example of using the function square ## [1] 100 3.2.3 Example 2 Let’s write another function that takes a single number (assumed to be an integer) as input and outputs another number according to the following rule: + if the input number is positive and even, return the number 2 + if the input number if positive and odd, return the number 1 + if the input number is not positive and even, return the number -2 + if the input number if not positive and odd, return the number -1 PositiveEven &lt;- function(x) { if( x &gt; 0 &amp;&amp; x%%2==0 ) { return_value &lt;- 2 } else if( x &gt; 0 &amp;&amp; x%%2==1 ){ return_value &lt;- 1 } else if( x &lt;= 0 &amp;&amp; x%%2==0) { return_value &lt;- -2 } else { return_value &lt;- -1 } return( return_value ) } Now, let’s look at a few examples of calling our function PositiveEven: PositiveEven(3) ## [1] 1 PositiveEven(-6) ## [1] -2 PositiveEven(0) ## [1] -2 PositiveEven(4) ## [1] 2 We could make our function PositiveEven a bit more user-friendly by having our function throw an error whenever the user inputs a number that is not an integer. PositiveEvenSafe &lt;- function(x) { # Function named PositiveEvenSafe if( x%%1 != 0) { # x%%1 will equal 0 if x is an integer stop(&quot;x must be an integer&quot;) # The stop function will stop the execution # of the function and will return an error } if( x &gt; 0 &amp;&amp; x%%2==0 ) { return_value &lt;- 2 } else if( x &gt; 0 &amp;&amp; x%%2==1 ){ return_value &lt;- 1 } else if( x &lt;= 0 &amp;&amp; x%%2==0) { return_value &lt;- -2 } else { return_value &lt;- -1 } return( return_value ) } Now, let’s see what happens if we call the function PositiveEvenSafe with the argument x = 2 and then x = 7.1 PositiveEvenSafe(2) ## [1] 2 PositiveEvenSafe(7.1) Error in PositiveEvenSafe(7.1) : x must be an integer 3.2.4 Rules for choosing function names All the same rules for variable names apply to rules for choosing function names. Examples of valid and invalid function names include: Valid_Function_Names Invalid_Function_Names i 2things my_function location@ answer42 _user.name .name .3rd Another rule to keep in mind is that you cannot use a reserved word as a function name or variable name. You can use built-in function names (for example, the print function) for your own functions, but this is NOT RECOMMENDED. The following are the reserved words in R: if else while function for in next break TRUE FALSE NULL Inf NA NA_integer NA_real NA_complex NA_character You can find the list of reserved words in R by typing ?reserved directly in the R console 3.3 Default argument values in functions We can provide default values for function parameters/arguments by adding = default_value after the parameter If an argument is specified in the function call, the specified one is used Otherwise; the default argument value is used In the function definition, it is generally better (though not required) to put parameters without default arguments before those with default arguments. When calling a function, arguments must be specified for every parameter without default arguments. Unlike Python, in R you can mix arguments with/without default arguments in an arbitrary order (though I don’t recommend it). 3.3.1 Example 1 As an example, let’s write a function that adds 3 numbers and, as a default, sets one of these numbers to zero: add3 &lt;- function(x, y, z=0) { return(x + y + z) } The default value for z here is \\(0\\). add3(1, 2) ## omit z ## [1] 3 add3(1, 2, 0) ## this should give the same as add3(1,2) ## [1] 3 add3(1, 2, 3) ## set z to 3 instead of 0 ## [1] 6 3.4 Specifying function arguments with keywords We can specify how arguments are passed to parameters not only by their order but by names with keyword arguments. Keyword arguments: have to do with how you call a function - not with the function definition itself. For example, we could call our function add3 with keywords in the following way: add3(2, 2, 1) # Call function using original positions ## [1] 5 add3(x=2, y=2, z=1) # Call function using keywords ## [1] 5 add3(y=2, x=2, z=1) # With keywords, position does not matter ## [1] 5 3.4.1 Example 1 The function foo below has parameters x, y,, z, w. The default value of z is \\(0\\), and the default value of w is TRUE. foo &lt;- function (x, y, z=0, w=TRUE) { if(w) { 1000*x + 100*y + 10*z ## this is equivalent to return(...) } else { 1000*x - 100*y + 10*z } } Let’s try calling foo using the original position of the arguments in the function definition. foo(9, 3, 5,TRUE) ## specify all arguments ## [1] 9350 foo(9, 3, 5) ## omit argument w ## [1] 9350 foo(9, 3) ## omit both z and w ## [1] 9300 Now, let’s try calling foo using keyword arguments and change the orders of x and y. ## foo(9) ## this will cause error because y is unknown foo(x=9, y=5) ## specify x and y as keyword arguments ## [1] 9500 We can even switch the positions of x and y when using keyword arguments foo(y=5, x=9) ## when using keywords, argument order doesn&#39;t matter ## [1] 9500 You can even mix which arguments you specify as positional and keyword: foo(9, y=5) ## specify x as positional, y as keyword argument ## [1] 9500 foo(9, z=3, y=5) ## y,z are keyword arguments, x is positional ## [1] 9530 3.5 Exercises Suppose we define the function quiz as quiz &lt;- function(bool_var1, x=0, bool_var2 = TRUE) { y &lt;- 0 if(bool_var1 &amp;&amp; bool_var2) { y &lt;- x + 2 } else { if(bool_var1) { y &lt;- x - 2 } } return(y) } What value does the following function call return? quiz(FALSE, 1.3) Write an R function that implements the following mathematical function in R \\[\\begin{equation} L(x, y) = \\begin{cases} 0 &amp; \\text{ if } x = 0 \\text{ and } y = 0 \\nonumber \\\\ 1 &amp; \\text{ if } x \\neq 0 \\text{ and } y = 0 \\nonumber \\\\ |x| &amp; \\text{ if } y = 1 \\nonumber \\\\ x^{2} &amp; \\text{ if } y = 2 \\nonumber \\end{cases} \\end{equation}\\] The function should have user-provided arguments x and y and should return NA if y does not equal either \\(0\\), \\(1\\), or \\(2\\) Write an R function called PropGtZero which returns the proportion of three entered numbers which are greater than \\(0\\). The function should have the following function definition PropGtZero &lt;- function(x, y, z, gt=TRUE) { } If gt=TRUE, then PropGtZero should return the proportion of the numbers x, y, z which are greater than \\(0\\). If gt=FALSE, then PropGtZero should return the proportion of the numbers x, y, z which are lesser than or equal to \\(0\\). If one or more of x, y, z, is NA, the function should return NA. For example, PropGtZero(3,2,-2) should return \\(2/3\\). "],["loops.html", "Chapter 4 Loops in R", " Chapter 4 Loops in R x "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
