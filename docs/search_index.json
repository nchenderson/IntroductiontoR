[["intro.html", "An Introduction to R programming Chapter 1 Getting Started 1.1 Using R as a calculator 1.2 Variables in R 1.3 Rules for choosing variable names in R 1.4 Examples of valid and invalid variable names in R 1.5 Variable Assignment 1.6 Types of variables 1.7 R Operations with numbers 1.8 Exercises", " An Introduction to R programming Nicholas Henderson 2022-09-04 Chapter 1 Getting Started 1.1 Using R as a calculator You can use R as a basic calculator. For example, if we just type in 42 + 17 into the R console, it should print out the sum: 42 + 17 ## [1] 59 We can compute the square root of 243, \\(1.56^{124}\\), and \\(7.21 \\times 8^{4}\\), just by typing these expressions into the R console sqrt(243) ## [1] 15.58846 1.56*124 ## [1] 193.44 7.21*8^4 ## [1] 29532.16 1.2 Variables in R When working with more complicated mathematical operations in R, it is often useful to store intermediate values in named variables. For example, x &lt;- (42 + 17)*sqrt(43) y &lt;- 7.21*8^4 + log(2.34) z &lt;- x/y z ## print out the value of z ## [1] 0.01310022 Here, x, y, and z are examples of variables. The pair of characters &lt;- used together is known as the assignment operator in R. x &lt;- 2 assigns the value 2 to the variable x. A variable is the named storage of a value (or an object) in memory. Why do we need variables? To reuse the same value later on. To generalize an expression to use in many cases. How to use variables in R? To set the value of a variable, use assignment operator &lt;- To use the value, simply use the variable name as if it were its stored value. For example, … 1.3 Rules for choosing variable names in R Variables can be named however you want as long as you follow the several variable-naming rules that R has. In R variable names can include the following: letters: A-Z a-z digits: 0-9 underscore and period: _ . Additional rules: Variable names must start with letters or a period (not underscore or digits) If a variable name starts with a period, it cannot be followed by a number. Variable names are case sensitive. 1.4 Examples of valid and invalid variable names in R Valid Invalid i 2things my_variable location@ answer42 _user.name .name .3rd While you are free to choose variable names however you like as long as you follow the variable-naming rules of R, making variable names descriptive is highly recommended. Descriptive variable names make it easier to read code. This is very helpful if: You are sharing your code or Looking back at code you wrote many weeks/months ago Using a consistent convention for naming variables is recommended, too: https://r4ds.had.co.nz/workflow-basics.html 1.5 Variable Assignment Variables can be assigned using either &lt;- or = x = 123 # Use = to assign a variable y &lt;- 123 # Or use &lt;- to assign a variable x # Retrieve the value of x ## [1] 123 y # Retrieve the value of y ## [1] 123 The pair of characters &lt;- is the classic symbol used for variable assignment in R. The use of &lt;- instead of = is often recommended in R style guides: http://adv-r.had.co.nz/Style.html 1.5.1 &lt;- vs. = &lt;- and = will work the same if they are both used in the “usual way” (when assigning variables within or outside of a function). One exception, is when used inside a function call. For example, if we use = in the function sd(x): sd(x = c(1,2,3,4,5)) # only sets the argument x in sd(x) to (1,2,3,4,5) ## [1] 1.581139 #x ## will return an error if we try to print x sd(x &lt;- c(1,2,3,4,5)) # This actually assigns the vector (1,2,3,4,5) to x ## [1] 1.581139 x ## [1] 1 2 3 4 5 However, using something like sd(x &lt;- c(1,2,3,4,5)) where we assign variables in a function call is not really done that often. It is not common to assign variables in a function call (I never do it). Whenever, using a function f with a keyword such as x, you will generally want to call that function using f(x = ...) So, in my opinion, there is not really a strong reason to prefer using &lt;- over = for assignment. There are other justifications for using &lt;- such as the ability to do assignment from the left by using the reverse symbol -&gt; c(1, 2, 3, 4) -&gt; a # Using c(1,2,3,4) = a will not work! a ## [1] 1 2 3 4 1.6 Types of variables Variables can be used to store different types of values. Common types include numeric, text, and logical values. x &lt;- 3.2 x ## [1] 3.2 Here, x is actually a vector (basically a collection of elements storing the same type of data). It is a vector of length one (i.e., it only has one element). This is the reason why you see [1] printed out next to the number 3.2. This means that the first element of the vector x is \\(3.2\\). R treats every variable as some type of collection (e.g., vectors, matrices, lists, etc.). There are no separate data types in R for individual numbers. The elements in a vector can have different types (or modes). You can find the types of the elements in a vector by using the function typeof y &lt;- sqrt(1743) typeof(y) # double and integer are the two numeric types ## [1] &quot;double&quot; z &lt;- 3 # R automatically treats every number as double z ## [1] 3 typeof(z) ## [1] &quot;double&quot; The other common types for the elements in a vector include logical (TRUE or FALSE) values character basically text, e.g., “hello”, “car”, … y &lt;- TRUE typeof(y) ## [1] &quot;logical&quot; z &lt;- &quot;dog&quot; # to define a character variable, place it inside quotes typeof(z) ## [1] &quot;character&quot; We will discuss these types in more detail later on when we discuss vectors, matrices, and lists. 1.7 R Operations with numbers As we mentioned before, … Operator Meaning Example Result + addition 5 + 8 13 - subtraction 90 - 10 80 * multiplication 4 * 7 28 / division 7 / 2 3.5 %% remainder 7 %% 2 1 ^ exponent 3 ^ 4 81 ** exponent 3 ** 4 81 R operations with numbers have similar precedence rules to arithmetic operations Operator Description Precedence +, - addition and subtraction low *, /, %% multiplication, division, remainder … **, ^ exponentiation … (expressions…) Parenthesis high Examples of operation precedence can be seen when typing the following expressions into the R console: 1 + 2 *3 ^ 4 # power &gt; mult/div &gt; add/sub ## [1] 163 (1 + 2 ) *3 ^ 4 # parenthesis &gt; power ## [1] 243 1.8 Exercises Compute the number \\[\\begin{equation} \\frac{\\sqrt{1.43 + 5^{1.2}}}{3} \\end{equation}\\] directly in the R console. Write an R script that assigns the value … \\[\\begin{equation} \\ln\\Big( 1 + \\exp(-2^{1.4}) \\Big) + \\ln\\Big(1 + 2\\exp(3^{1.7}) \\Big) \\end{equation}\\] … to a variable named x and prints the result in the Console when you run the script. Which of the following is NOT a valid variable name in R? .independent_variable3 _independent_variable3 independent_variable3 independent.variable3 "],["ifelse.html", "Chapter 2 Logical Expressions and If-Else Statements in R 2.1 Logical Expression in R", " Chapter 2 Logical Expressions and If-Else Statements in R 2.1 Logical Expression in R A Logical expression is an expression that evaluates to either TRUE or FALSE. The following are examples of logical expressions in R: 4 &gt; 2 3 &lt;= 5 15.0 + 1.3*1.3 &gt; 17.0 \"cat\" == \"dog\" Each of the above expressions will evaluate to either TRUE or FALSE if you run them in R. 4 &gt; 2 ## [1] TRUE 3 &lt;= 5 ## [1] TRUE 15.0 + 1.3*1.3 &gt; 17.0 ## [1] FALSE x &lt;- &quot;cat&quot; == &quot;dog&quot; # assign to the variable x the value # returned by this logical expression x ## [1] FALSE Most logical expressions are constructed by using some combination of: Comparison operators (&lt;, &lt;=, ==, !=) Logical operators (and, or, not) (in R: &amp;&amp;, ||, !) 2.1.1 Comparison Operators Operator Meaning Example Result &lt; Less than 5 &lt; 3 FALSE &gt; Greater than 5 &gt; 3 TRUE &lt;= Less than or equal to 3 &lt;= 6 TRUE &gt;= Greater than or equal to 4 &gt;= 3 TRUE == Equal to 2 == 2 TRUE != Not equal to ‘str’ != ‘stR’ TRUE 2.1.2 Logical Operators The first main logical operator we will discuss is the logical AND In R, the logical operator &amp;&amp; is used to represent the logical AND The logical AND is used to test whether or not two statements are both true. For two logical expressions A and B, the logical expression A &amp;&amp; B is true only if both A and B evaluate to true. 4 &gt; 2 &amp;&amp; 5/2 == 1 ## only the first statement is TRUE ## [1] FALSE 4 &gt; 2 &amp;&amp; &quot;car&quot; == &quot;truck&quot; ## only the first statement is TRUE ## [1] FALSE 4 &gt; 2 &amp;&amp; 3 &lt; 5 ## both statements are TRUE ## [1] TRUE "],["functions.html", "Chapter 3 Functions in R 3.1 Built-in R functions 3.2 Construction your own R functions 3.3 Default argument values in functions 3.4 Specifying function arguments with keywords 3.5 Exercises", " Chapter 3 Functions in R A function in R can be thought of as a sequence of statements that takes some input, uses that input to compute something, and then returns a result. Why do we need functions? To modularize a task so that we can reuse the same code in many places. To increase readability of code. To reduce redundancy and reduce the number of errors. 3.1 Built-in R functions base R has many useful built-in functions that you can use. Other R packages are another source of useful functions. R’s base package is loaded by default. A few other packages including graphics, stats, and *utils are usually loaded by default as well. The base package includes many widely-used functions, such as the []print() or the sum() function. There are many other R packages available which contain many useful functions. 3.2 Construction your own R functions You can write your own functions as needed. While base R and the many available R packages have a wide range of useful functions, being able to write your own functions gives you much greater flexibility when working with R. 3.2.1 Function Definition Syntax There are three key components of a function definition in R. Function name: the name which will be used to call the function Function arguments: values to pass to a function as input. Return value: the value returned by a function as output. The general syntax for writing your own R function is: function_name &lt;- function(params){ ## function_name is the name of the function ## params name of the input variable within this function statement1 ## statements executed when the function is called statement2 ## statements convert params into some value to be ... ## returned return(return_value) ## return the variable return_value } 3.2.2 Example 1 Let’s write a function that takes a number as an input and returns the square of that number. ## define a new function named square square &lt;- function(x) { ## function name: square, argument : x return(x*x) ## returns x*x } Once we have defined square, we can use it as many times as we would like. After defining the function, each time the function is used is referred to as calling the function. Let’s try calling square with an input number of 10: square(10) ## example of using the function square ## [1] 100 3.2.3 Example 2 Let’s write another function that takes a single number (assumed to be an integer) as input and outputs another number according to the following rule: + if the input number is positive and even, return the number 2 + if the input number if positive and odd, return the number 1 + if the input number is not positive and even, return the number -2 + if the input number if not positive and odd, return the number -1 PositiveEven &lt;- function(x) { if( x &gt; 0 &amp;&amp; x%%2==0 ) { return_value &lt;- 2 } else if( x &gt; 0 &amp;&amp; x%%2==1 ){ return_value &lt;- 1 } else if( x &lt;= 0 &amp;&amp; x%%2==0) { return_value &lt;- -2 } else { return_value &lt;- -1 } return( return_value ) } Now, let’s look at a few examples of calling PositiveEven: PositiveEven(3) ## [1] 1 PositiveEven(-6) ## [1] -2 PositiveEven(0) ## [1] -2 PositiveEven(4) ## [1] 2 We could make our function PositiveEven a bit more user-friendly by having our function throw an error whenever the user inputs a number that is not an integer. PositiveEvenSafe &lt;- function(x) { # Function named PositiveEvenSafe if( x%%1 != 0) { # x%%1 will equal 0 if x is an integer stop(&quot;x must be an integer&quot;) # The stop function will stop the execution # of the function and will return an error } if( x &gt; 0 &amp;&amp; x%%2==0 ) { return_value &lt;- 2 } else if( x &gt; 0 &amp;&amp; x%%2==1 ){ return_value &lt;- 1 } else if( x &lt;= 0 &amp;&amp; x%%2==0) { return_value &lt;- -2 } else { return_value &lt;- -1 } return( return_value ) } Now, let’s see what happens if we call the function PositiveEvenSafe with the argument x = 2 and then x = 7.1 PositiveEvenSafe(2) ## [1] 2 PositiveEvenSafe(7.1) Error in PositiveEvenSafe(7.1) : x must be an integer 3.2.4 Rules for choosing function names All the same rules for variable names apply to rules for choosing function names. Examples of valid and invalid function names include: Valid_Function_Names Invalid_Function_Names i 2things my_function location@ answer42 _user.name .name .3rd Another rule to keep in mind is that you cannot use a reserved word as a function name or variable name. You can use built-in function names (for example, the print function) for your own functions, but this is NOT RECOMMENDED. The following are the reserved words in R: if else while function for in next break TRUE FALSE NULL Inf NA NA_integer NA_real NA_complex NA_character You can find the list of reserved words in R by typing ?reserved directly in the R console 3.3 Default argument values in functions We can provide default values for function parameters/arguments by adding = default_value after the parameter If an argument is specified in the function call, the specified one is used Otherwise; the default argument value is used In the function definition, it is generally better (though not required) to put parameters without default arguments before those with default arguments. When calling a function, arguments must be specified for every parameter without default arguments. Unlike Python, in R you can mix arguments with/without default arguments in an arbitrary order (though I don’t recommend it). 3.3.1 Example 1 As an example, let’s write a function that adds 3 numbers and, as a default, sets one of these numbers to zero: add3 &lt;- function(x, y, z=0) { return(x + y + z) } The default value for z here is \\(0\\). add3(1, 2) ## omit z ## [1] 3 add3(1, 2, 0) ## this should give the same as add3(1,2) ## [1] 3 add3(1, 2, 3) ## set z to 3 instead of 0 ## [1] 6 3.4 Specifying function arguments with keywords We can specify how arguments are passed to parameters not only by their order but by names with keyword arguments. Keyword arguments: have to do with how you call a function - not with the function definition itself. For example, we could call our function add3 with keywords in the following way: add3(2, 2, 1) # Call function using original positions ## [1] 5 add3(x=2, y=2, z=1) # Call function using keywords ## [1] 5 add3(y=2, x=2, z=1) # With keywords, position does not matter ## [1] 5 3.4.1 Example 1 The function foo below has parameters x, y,, z, w. The default value of z is \\(0\\), and the default value of w is TRUE. foo &lt;- function (x, y, z=0, w=TRUE) { if(w) { 1000*x + 100*y + 10*z ## this is equivalent to return(...) } else { 1000*x - 100*y + 10*z } } Let’s try calling foo using the original position of the arguments in the function definition. foo(9, 3, 5,TRUE) ## specify all arguments ## [1] 9350 foo(9, 3, 5) ## omit argument w ## [1] 9350 foo(9, 3) ## omit both z and w ## [1] 9300 Now, let’s try calling foo using keyword arguments and change the orders of x and y. ## foo(9) ## this will cause error because y is unknown foo(x=9, y=5) ## specify x and y as keyword arguments ## [1] 9500 We can even switch the positions of x and y when using keyword arguments foo(y=5, x=9) ## when using keywords, argument order doesn&#39;t matter ## [1] 9500 You can even mix which arguments you specify as positional and keyword: foo(9, y=5) ## specify x as positional, y as keyword argument ## [1] 9500 foo(9, z=3, y=5) ## y,z are keyword arguments, x is positional ## [1] 9530 3.5 Exercises Suppose we define the function quiz as quiz &lt;- function(bool_var1, x=0, bool_var2 = TRUE) { y &lt;- 0 if(bool_var1 &amp;&amp; bool_var2) { y &lt;- x + 2 } else { if(bool_var1) { y &lt;- x - 2 } } return(y) } What value does the following function call return? quiz(FALSE, 1.3) Write an R function that implements the following mathematical function in R \\[\\begin{equation} L(x, y) = \\begin{cases} 0 &amp; \\text{ if } x = 0 \\text{ and } y = 0 \\nonumber \\\\ 1 &amp; \\text{ if } x \\neq 0 \\text{ and } y = 0 \\nonumber \\\\ |x| &amp; \\text{ if } y = 1 \\nonumber \\\\ x^{2} &amp; \\text{ if } y = 2 \\nonumber \\end{cases} \\end{equation}\\] The function should have user-provided arguments x and y and should return NA if y does not equal either \\(0\\), \\(1\\), or \\(2\\) Write an R function called PropGtZero which returns the proportion of three entered numbers which are greater than \\(0\\). The function should have the following function definition PropGtZero &lt;- function(x, y, z, gt=TRUE) { } If gt=TRUE, then PropGtZero should return the proportion of the numbers x, y, z which are greater than \\(0\\). If gt=FALSE, then PropGtZero should return the proportion of the numbers x, y, z which are lesser than or equal to \\(0\\). If one or more of x, y, z, is NA, the function should return NA. For example, PropGtZero(3,2,-2) should return \\(2/3\\). "],["loops.html", "Chapter 4 Loops in R 4.1 For Loops 4.2 While Loops 4.3 Exercises", " Chapter 4 Loops in R Loops are typically used when we want to repeat some type of calculation many times. The two types of loops in R are the for loop and the while loop. For loops: Typically used when we know exactly how many times we need to repeat a calculation. While loops: Typically used when we only want to repeat some calculation until some condition is satisfied. 4.1 For Loops The general form of a for loop in R is for (x in vec_name) { perform a calculation (often involving x) } The for loop will execute the code underneath the for statement \\(T\\) times where \\(T\\) is the length of the vector vec_name. Each time the code is executed, x will be set to one element in vec_name. 4.1.1 Example 1: printing the first 5 integers As an example, let’s write a for loop that prints the first 5 positive integers: for (k in 1:5) { print(k) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Each time you go inside the loop, the variable k takes the next value in the vector 1:5 and is printed to the screen. 4.1.2 Example 2: computing 10 factorial As another example, let’s use a for loop to compute the product \\[\\begin{equation} 10! = 1 \\times 2 \\times 3 \\times ... \\times 9 \\times 10 \\nonumber \\end{equation}\\] prod_ten &lt;- 1 # start from 1 for(x in 2:10) { # iterate x from 1 thru 10 prod_ten &lt;- prod_ten*x # multiply each value } print(prod_ten) # print the product of first 10 integers ## [1] 3628800 4.1.3 Example 3: a non-numeric looping variable The looping variable does not need to be numeric. Here is an example where the looping variable is a character. fruits &lt;- c(&quot;apple&quot;,&quot;orange&quot;,&quot;grape&quot;) # character vector for(fruit in fruits) { # iterate each element print(fruit) } ## [1] &quot;apple&quot; ## [1] &quot;orange&quot; ## [1] &quot;grape&quot; 4.1.4 Example 4: first Fibonacci numbers The Fibonacci sequence is a sequence of numbers \\(x_{1}, x_{2}, x_{3}, ...\\) defined by the relationship: \\[\\begin{equation} x_{k} = x_{k-1} + x_{k-2} \\nonumber \\end{equation}\\] The first two numbers in the Fibonacci sequence are \\(x_{1} = 0\\) and \\(x_{2} = 1\\). We want to write R code that stores the first \\(n\\) Fibonacci numbers in a vector. To do this, it is more efficient to first create a vector of zeros and then fill in the Fibonacci numbers into this vector. This is done by first assigning x the vector rep(0, n) ## R code for computing first 12 Fibonacci numbers x &lt;- rep(0, 12) # First initialize a vector of size 12 x[1] &lt;- 0 x[2] &lt;- 1 for(k in 3:12) { ## start at index 3 since first 2 elements are filled in x[k] &lt;- x[k-1] + x[k-2] } x ## [1] 0 1 1 2 3 5 8 13 21 34 55 89 You could create a vector of the first \\(n\\) Fibonacci numbers by “appending” an extra number to the vector x each time we go in the loop. This is usually much slower than first initializing a vector as was done on the previous slide. ## R code for computing first 12 Fibonacci numbers x &lt;- c(0, 1) for(k in 3:12) { x &lt;- c(x, x[k-1] + x[k-2]) } x ## [1] 0 1 1 2 3 5 8 13 21 34 55 89 4.1.5 Nested for loops You can have a for loop within another for loop. These are usually referred to as nested for loops. for (i in 1:3) { # i iterates over 1,2,3 for (j in 1:i) { # j iterates over 1 to i print(c(i,j)) } } ## [1] 1 1 ## [1] 2 1 ## [1] 2 2 ## [1] 3 1 ## [1] 3 2 ## [1] 3 3 4.1.6 Exiting for loops and skipping iterations: break and next You can use the break statement to terminate a loop. The for loop will be stopped whenever the statement break is encountered. As an example of this, let’s write a loop that should run for 5 iterations, but is terminated after during it’s 3rd iteration. for(k in 1:5) { print(k) if(k &gt;= 3) { break ## loop will stop when break is run } } ## [1] 1 ## [1] 2 ## [1] 3 Note that if we move the print statement after break in the above example, then only 1 and 2 will be printed to the screen. for(k in 1:5) { if(k &gt;= 3) { break ## loop will stop when break is run } print(k) } ## [1] 1 ## [1] 2 break statements can be used within nested loops. If using a break statement in the inner loop of a nested loop, only the inner loop will be terminated when break is run. for (i in 1:3) { # i iterates over 1,2,3 for (j in 1:3) { # j iterates over 1,2,3 print(c(i,j)) if (j == i) { ## if j and i are the same break ## finish the inner loop } } } ## [1] 1 1 ## [1] 2 1 ## [1] 2 2 ## [1] 3 1 ## [1] 3 2 ## [1] 3 3 The next statement is used to skip the remainder of a current iteration. When the next statement is encountered, you will go directly to the next iteration and not execute whatever was remaining inside the body of the for loop. Let’s try an example where we have 5 iterations setup, but we use a next statement within the 3rd iteration for(k in 1:5) { if(k == 3) { next } print(k) # this will not print when k==3 } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 next can also be used within a nested loop. If used in an inner loop, the next statement will skip the remainder of the current inner loop iteration and go to the next inner loop iteration. for (i in 1:3) { # i iterates over 1,2,3 for (j in 1:3) { # j iterates over 1,2,3 if (j == i) { ## if j equals i next ## go to next iteration } ## of inner loop print(c(i,j)) } } ## [1] 1 2 ## [1] 1 3 ## [1] 2 1 ## [1] 2 3 ## [1] 3 1 ## [1] 3 2 4.2 While Loops For loops execute a piece of code a set number of times. While loops keep executing the piece of code as long as a certain condition is TRUE. The general form of a while loop in R is while(condition) { code chunk then, usually update something related to condition } condition is a logical expression. The code_chunk inside the loop is repeated until the condition becomes FALSE in which case the loop stops. Basic example of while loop: prod &lt;- 1 # start from 1 while(prod &lt; 100) { # repeat the block until condition is true print(prod) # print the value of prod prod &lt;- prod * 2 # and double the value } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 8 ## [1] 16 ## [1] 32 ## [1] 64 4.2.1 Example 1: a “first which” function We can use a while loop to find the first occurrence of a number in a vector. Specifically, for an input vector x and input number num, we want to find the first index k such that x[k] == num This function will also return NA if no match is found. first_while &lt;- function(x, num) { index.count &lt;- 0 match.not.found &lt;- TRUE while(match.not.found &amp;&amp; index.count &lt; length(x)) { # want to keep loop running while match is not found # and the index is less than the length of x index.count &lt;- index.count + 1 match.not.found &lt;- !(x[index.count] == num) } if(match.not.found) { index.count &lt;- NA } return(index.count) } Let’s try running first_while on a few examples: first_while(1:5, 3) ## [1] 3 first_while(1:5, 6) ## [1] NA first_while(1:5, 5) ## [1] 5 first_while(rep(1:3, each=4), 2) ## [1] 5 4.3 Exercises "],["vectors.html", "Chapter 5 Vectors in R 5.1 Creating vectors in R 5.2 Subsets of vectors 5.3 Useful methods for vectors 5.4 Vectors with different data types 5.5 Mathematical operations with vectors 5.6 Set operations with vectors 5.7 NA and is.na(): missing values in R 5.8 Exercises", " Chapter 5 Vectors in R The most basic data type in R is the vector. As we mentioned previously, if we assign the number 42 to a variable named x, R will treat x as a vector. x &lt;- 42 ## the x value is 42 x ## print the value of x ## [1] 42 x[1] ## What does this do? ## [1] 42 Here, x is considered to be a vector of length 1. Vectors that are homogenous (all elements have the same type) are more technically referred to as atomic vectors in R. It is common to refer to any atomic vector as a vector. We will also refer to any atomic vector as a vector. R will always store data as a “collection”. Dimension Homogeneous Heterogeneous 1-Dimension Atomic Vector List 2-Dimensions Matrix Data Frame &gt;2-Dimensions Multi-dimensional array There is no “0-dimensional data” in R. Even a single-valued object is considered to be a “vector” with length 1. Source: http://adv-r.had.co.nz/Data-structures.html 5.1 Creating vectors in R 5.1.1 The concatenate function c() The most straightforward way to create vectors in R is to use the concatenate function c() This links together a group of values into a single vector. You can also create a single vector from multiple vectors using c. Examples of using c() to create numeric vectors are: x &lt;- c(1,2,3) # create a length-3 vector with elements 1, 2, and 3 x ## [1] 1 2 3 y &lt;- c(x, 4, 5) # create a vector with elements 1,2,3,4,5 y ## [1] 1 2 3 4 5 You are not limited to using numeric values with c(). For example, you can use c() to create a vector of characters or logicals. char_vec &lt;- c(&quot;cat&quot;, &quot;dog&quot;, &quot;hamster&quot;) # vector of characters char_vec ## [1] &quot;cat&quot; &quot;dog&quot; &quot;hamster&quot; log_vec &lt;- c(TRUE, FALSE, TRUE, TRUE) # vector of logicals log_vec ## [1] TRUE FALSE TRUE TRUE 5.1.2 colon, seq, rep: Creating vectors with specific patterns It is often very useful to be able to create vectors with specific patterns. The colon operator : can be used to create a sequence of numbers. The code from:end will create a vector of numbers starting at from and increasing (or decreasing) by 1 until reaching end. Examples: x &lt;- 1:5 # creates the vector (1,2,3,4,5) x ## [1] 1 2 3 4 5 y &lt;- 22:28 y ## [1] 22 23 24 25 26 27 28 You can also use the colon operator to create a decreasing sequence of numbers. z &lt;- 0:-5 # use : to created decreasing vector z ## [1] 0 -1 -2 -3 -4 -5 You can even have use a number with a decimal point as the starting or ending number (but this is not done that frequently). w &lt;- 2.3:6.8 # it keeps increasing by 1 until it reaches # largest value less than 6.8 w ## [1] 2.3 3.3 4.3 5.3 6.3 Be careful when using something like a:b-1 when creating a vector b &lt;- 6 u &lt;- 1:b - 1 # This does not create the vector 1,2,...,b-1 u ## [1] 0 1 2 3 4 5 u &lt;- 1:(b-1) # use this to create vector 1,2,...,b-1 u ## [1] 1 2 3 4 5 The function seq is a useful function for creating vectors that have desired starting and ending values. seq provides more flexibility than the colon operator : You can use seq to create a sequence with different increments than \\(1\\) seq(1, 11, by=2) # sequence that increases by 2 ## [1] 1 3 5 7 9 11 seq(1, 10, by=2) # stops at 9 since 11 is larger than 10 ## [1] 1 3 5 7 9 seq(1, 11, by=2.54) # increment by non-integer amount ## [1] 1.00 3.54 6.08 8.62 Use the length.out argument in seq to create an equally-spaced vector with a given length. seq(1, 11, length.out=11) # same as 1:11 ## [1] 1 2 3 4 5 6 7 8 9 10 11 seq(1, 11, length.out=6) # vector of length 6, with equal increments ## [1] 1 3 5 7 9 11 # using length.out is convenient seq(21.5, 48.2, length.out=5) # don&#39;t have to work out correct increments ## [1] 21.500 28.175 34.850 41.525 48.200 The rep() (replicate) function is very useful for creating vectors that have any kind of repeated pattern. The basic form of rep is rep(x, times) rep produces a vector which repeats the vector x times number of times. rep(7, 3) # just creates the vector 7,7,7 ## [1] 7 7 7 rep(c(2,4,6), 3) # repeats c(2, 4, 6) three times ## [1] 2 4 6 2 4 6 2 4 6 Using rep inside of c(): c(10:12, rep(c(2,4,6), 3)) ## [1] 10 11 12 2 4 6 2 4 6 2 4 6 Using rep with the keyword each will repeat each element of x each times before moving on to the next element of x. rep(c(2,4,6), each=4) # repeat each element 4 times ## [1] 2 2 2 2 4 4 4 4 6 6 6 6 5.2 Subsets of vectors 5.2.1 Extracting vector elements You can extract the \\(k^{th}\\) element of a vector by using vector_name[k] For example: x &lt;- c(1,3,5,100) x[2] # second element of x ## [1] 3 x[4] # fourth element of x ## [1] 100 You can also extract a subset of elements with indices stored by the vector vec_index from a vector by using vector_name[ vec_index ] For example: x &lt;- c(1,3,5,100, 1250) x[ c(1,3) ] # extract first and third elements of x ## [1] 1 5 x[ 3:5 ] # extract elements 3 through 5 of x ## [1] 5 100 1250 You can change the value of the \\(k^{th}\\) element of a vector by using vector_name[k] &lt;- new_value x &lt;- c(1,3,5,100) x[2] &lt;- 6 # you may update a single element print(x) ## [1] 1 6 5 100 You can also update multiple elements of a vector by placing a vector of indices inside brackets [] x[1:3] &lt;- rep(10,3) # update first 3 elements of x print(x) ## [1] 10 10 10 100 5.2.2 Subsetting with logical expressions We described above how you can take a subset of a vector by specifying the vector indeces that you want for your subset. You can also subset a vector using a logical expression rather than explicitly specifying the indeces you want. x &lt;- c(10, 2, 21, 15) y &lt;- x[x &gt; 8] # returns all elements of x greater than 8 z &lt;- x[x &gt; 12] # returns all elements of x greater than 12 y ## [1] 10 21 15 z ## [1] 21 15 You can think of the expression x[x &gt; 8] as doing the following: x[c(TRUE, FALSE, TRUE, TRUE)] ## [1] 10 21 15 5.2.3 The which function You can find the indeces of a vector that satisfy a certain condition using the which function. x &lt;- c(10, 2, 21, 15) which(x &gt; 20) # shows that x[3] &gt; 20 ## [1] 3 which(x &gt; 12) # shows that x[3] &gt; 12 and x[4] &gt; 12 ## [1] 3 4 The which function really just returns the indeces where a logical vector is TRUE which( c(FALSE, TRUE, FALSE) ) ## [1] 2 5.3 Useful methods for vectors The length function can tell you how many elements are in your vector: x &lt;- 9:0 x ## [1] 9 8 7 6 5 4 3 2 1 0 length(x) # length of the vector ## [1] 10 typeof(x) # type of elements ## [1] &quot;integer&quot; sum(x) # sum of values ## [1] 45 R has functions which allow you to compute all the well-known summary statistics from a numeric vector. x &lt;- 1:5 mean(x) # average of vector elements ## [1] 3 var(x) # variance (denominator is n-1) ## [1] 2.5 sd(x) # standard deviation (denominator is n-1) ## [1] 1.581139 x &lt;- 1:5 max(x) # maximum value ## [1] 5 min(x) # minimum value ## [1] 1 median(x) # median ## [1] 3 5.4 Vectors with different data types As we mentioned before, R vectors are not limited to having numeric elements. The main restriction for vectors is that they must have elements which are all the same type. x &lt;- c(1, 2.5, 42) ## numeric vector print(x) ## [1] 1.0 2.5 42.0 y &lt;- c(&quot;hello&quot;,&quot;world&quot;,&quot;biostat607&quot;) ## character vectors print(y) ## [1] &quot;hello&quot; &quot;world&quot; &quot;biostat607&quot; z &lt;- c(TRUE, FALSE, FALSE) ## logical vectors print(z) ## [1] TRUE FALSE FALSE You can “create” a vector that has mixed data types, but R will automatically convert the types of some of the elements so that all elements have the same type. x &lt;- c(TRUE, FALSE, FALSE) ## homogeneous logical vector print(x) ## [1] TRUE FALSE FALSE x &lt;- c(TRUE, FALSE, 2) ## contains logical and numeric values print(x) ## R translates logical TRUE/FALSE into numeric 1/0 ## [1] 1 0 2 x &lt;- c(1, 2, &quot;3&quot;) ## numeric + character print(x) ## R translates numeric values translates into characters ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; x &lt;- c(TRUE, 2, &quot;3&quot;) ## logical + numeric + character print(x) ## R translates logical and numeric values into characters ## [1] &quot;TRUE&quot; &quot;2&quot; &quot;3&quot; 5.4.1 Explicitly changing the data types You can convert a vector to another type using as.logical, as.numeric, or as.character. x &lt;- as.logical(c(0,1,2,3)) # numeric to logical conversion print(x) ## [1] FALSE TRUE TRUE TRUE x &lt;- as.numeric(c(TRUE,FALSE, T,F)) # logical to numeric print(x) ## [1] 1 0 1 0 x &lt;-as.character(c(0,1,2,3)) # numeric to string print(x) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; Sometimes conversion of a vector does not work ## When a character cannot be converted, it returns NA ## as an invalid number as.numeric(c(&quot;123&quot;,&quot;12.3&quot;,&quot;123a&quot;)) ## Warning: NAs introduced by coercion ## [1] 123.0 12.3 NA ## Characters cannot be converted into logical values as.logical(c(&quot;TRUE&quot;,&quot;FALSE&quot;, &quot;T&quot;,&quot;TF&quot;,0)) ## [1] TRUE FALSE TRUE NA NA as.integer(c(123, 12.3, &quot;123&quot;, &quot;123a&quot;)) ## Warning: NAs introduced by coercion ## [1] 123 12 123 NA 5.5 Mathematical operations with vectors When doing mathematical operations with two vectors of the same length, R will perform addition, subtraction, multiplication, division element-by-element. x &lt;- c(10, 5, 0) y &lt;- 1:3 x+y # element-wise addition ## [1] 11 7 3 x*y # element-wise multiplication ## [1] 10 10 0 x^y # element-wise power ## [1] 10 25 0 Multiplying or dividing a vector by a single number multiplies (or divides) each element by that number x &lt;- c(10, 5, 0, -5) 3*x ## [1] 30 15 0 -15 x/2 ## [1] 5.0 2.5 0.0 -2.5 Adding or subtracting a vector by a single number also adds (or subtracts) each element by that number x &lt;- c(10, 5, 0, -5) 3 + x # Actually an example of recycling with a one-element vector ## [1] 13 8 3 -2 5.5.1 Recycling rules You can actually add/subtract vectors of different lengths. When doing this, R recycles the values in the shorter vector R will print out a warning message if the length of the longer vector is not a multiple of the shorter vector c(1, 2, 4) + c(6, 0, 9, 10) ## Warning in c(1, 2, 4) + c(6, 0, 9, 10): longer object length is not a multiple ## of shorter object length ## [1] 7 2 13 11 What the above code is doing is adding the vector c(1, 2, 4, 1) with the vector c(6, 0, 9, 10). Note that if we add a vector of length 3 with a vector of length 6 we will get no warning message. This is because \\(6\\) is a multiple of \\(3\\). c(1, 2, 4) + c(6, 0, 9, 10, 11, 12) ## [1] 7 2 13 11 13 16 The above code adds the vector c(1, 2, 4, 1, 2, 4) with the vector c(6, 0, 9, 10, 11, 12). I personally do not use recycling rules much when the length of **both vectors* is 2 or more. It’s probably good to be aware of recycling rules if you are getting this type of warning message. You may find it helpful to use these recycling rules if you are, for example, adding one vector with another vector that has a simple, repeating pattern. 5.5.2 Logical operations with vectors c(TRUE, TRUE, FALSE) &amp; c(TRUE,FALSE,FALSE) # element-wise ## [1] TRUE FALSE FALSE c(TRUE, TRUE, FALSE) | c(TRUE,FALSE,FALSE) # element-wise ## [1] TRUE TRUE FALSE c(TRUE, TRUE, FALSE) &amp;&amp; c(TRUE,FALSE,FALSE) # only first values ## [1] TRUE c(TRUE, TRUE, FALSE) || c(TRUE,FALSE,FALSE) # only first values ## [1] TRUE 5.6 Set operations with vectors You can also do set operations with vectors. When working with set operations, you should think of the set associated with a vector as the collection of unique elements from that vector. x &lt;- c(1,2,3,3,4,5) # x is c (1,2,3,3,4,5) y &lt;- c(1,3,3,5,7,9) # y is c (1,3,3,5,7,9) intersect(x,y) # set intersection, note that repeated 3 is dropped ## [1] 1 3 5 union(x,y) # set union ## [1] 1 2 3 4 5 7 9 setdiff(x,y) # set difference x - y ## [1] 2 4 x &lt;- 1:5 # x is c (1,2,3,4,5) y &lt;- c(1,3,3,5,7,9) # y is c (1,3,3,5,7,9) x %in% y # membership test ## [1] TRUE FALSE TRUE FALSE TRUE match(x, y) # find indices of first matching values ## [1] 1 NA 2 NA 4 setdiff(x, y) # set difference x-y ## [1] 2 4 5.7 NA and is.na(): missing values in R Missing data in R is usually represented by the value NA. NA stands for “Not Available” You can create a vector with NA values by just typing in NA for one of the vector elements. x &lt;- c(1, 5, NA, 4) # The third element of this vector is NA typeof(x) ## [1] &quot;double&quot; You can type in NA for either numeric or character variables. R will automatically convert everything to the appropriate type. y &lt;- c(&quot;cat&quot;, NA, &quot;dog&quot;) # The second element of this vector is NA typeof(y) ## [1] &quot;character&quot; Many of the built-in R functions will return NA if the input numeric vector contains any NA values. For example, if we try to compute the standard deviation of the vector x x &lt;- c(1, 5, NA, 4, 7) # The third element of this vector is NA mx &lt;- sd(x) # mx will have the value NA mx ## [1] NA You can compute the standard deviation of the non-NA values by including the argument na.rm = TRUE sx &lt;- sd(x, na.rm=TRUE) # sx shoud have the standard deviation of 1,5,4,7 sx ## [1] 2.5 In the function sd, the argument na.rm is a good example of an argument with a default value. You can see that na.rm has a default value by looking at the function definition for sd sd &lt;- function(x, na.rm = FALSE) { } The default value of na.rm is FALSE. So, you need to include na.rm = TRUE if you want sd to ignore missing values. 5.7.1 The function is.na() The function is.na() is often very useful when you’re working with data that has mising values. When applied to a vector, is.na() will return a vector of logical values with the same length as the input vector. The \\(k^{th}\\) element of is.na(x) will be TRUE if the \\(k^{th}\\) element of x is missing. Otherwise, the \\(k^{th}\\) element of is.na(x) will be FALSE. x &lt;- c(10, 3, 5, NA, 1, NA) # Elements 4 and 6 of x have NA values is.na(x) ## [1] FALSE FALSE FALSE TRUE FALSE TRUE You can also use is.na() directly on matrices and data frames. 5.8 Exercises Suppose we define the vector x as x &lt;- 1:10. What is the value of x[ seq(1, 10,by=2)][3]? Suppose x &lt;- rep(c(1, 5, 10), each=3). What is the value of sum( x[x &gt; 5] )? Create a vector called xvec that stores the following sequence of numbers: \\(1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ....\\) and keeps repeating this pattern until the last number is \\(10\\). What is the length of xvec? What number is the \\(35^{th}\\) element of xvec? What is the mean value of the numbers contained in xvec? How many elements of xvec equal \\(2\\)? How many elements of xvec equal \\(7\\)? What is the sum of all the even numbers contained in xvec? "],["matrix.html", "Chapter 6 Matrices in R", " Chapter 6 Matrices in R "],["list.html", "Chapter 7 Lists in R", " Chapter 7 Lists in R "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
