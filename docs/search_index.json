[["index.html", "An Introduction to R programming Preface", " An Introduction to R programming Nicholas Henderson 2022-09-17 Preface This book contains notes related to the R module of Biostatistics 607. "],["intro.html", "Chapter 1 Getting Started 1.1 Using R as a calculator 1.2 Variables in R 1.3 R Operations with numbers 1.4 Brief intro to vectors in R 1.5 Exercises", " Chapter 1 Getting Started 1.1 Using R as a calculator You can use R as a basic calculator. For example, if we just type in 42 + 17 into the R console, it should print out the sum: 42 + 17 ## [1] 59 We can compute the square root of 243, \\(1.56^{124}\\), and \\(7.21 \\times 8^{4}\\), just by typing these expressions into the R console sqrt(243) ## [1] 15.58846 1.56*124 ## [1] 193.44 7.21*8^4 ## [1] 29532.16 1.2 Variables in R When working with more complicated mathematical operations in R, it is often useful to store intermediate values in named variables. For example, the following R code creates the variables x, y, z and assigns them the values \\((42 + 17)\\sqrt{43}\\), \\(7.21(8^{4}) + \\ln(2.34)\\), and \\((42 + 17)\\sqrt{43}/[ 7.21(8^{4}) + \\ln(2.34) ]\\) respectively. x &lt;- (42 + 17)*sqrt(43) y &lt;- 7.21*8^4 + log(2.34) z &lt;- x/y z ## print out the value of z ## [1] 0.01310022 Here, x, y, and z are examples of variables. The pair of characters &lt;- used together is known as the assignment operator in R. x &lt;- 2 assigns the value 2 to the variable x. A variable is the named storage of a value (or an object) in memory. Why do we need variables? To reuse the same value later on. To generalize an expression to use in many cases. How to use variables in R? To set the value of a variable, use assignment operator &lt;- To use the value, simply use the variable name as if it were its stored value. For example, … 1.2.1 Rules for choosing variable names in R Variables can be named however you want as long as you follow the several variable-naming rules that R has. In R variable names can include the following: letters: A-Z a-z digits: 0-9 underscore and period: _ . Additional rules: Variable names must start with letters or a period (not underscore or digits) If a variable name starts with a period, it cannot be followed by a number. Variable names are case sensitive. The following tables shows examples of valid and invalid variable names in R Valid Invalid i 2things my_variable location@ answer42 _user.name .name .3rd While you are free to choose variable names however you like as long as you follow the variable-naming rules of R, making variable names descriptive is highly recommended. Descriptive variable names make it easier to read code. This is very helpful if: You are sharing your code or Looking back at code you wrote many weeks/months ago Using a consistent convention for naming variables is recommended, too: https://r4ds.had.co.nz/workflow-basics.html 1.2.2 Variable Assignment Variables can be assigned using either &lt;- or = x = 123 # Use = to assign a variable y &lt;- 123 # Or use &lt;- to assign a variable x # Retrieve the value of x ## [1] 123 y # Retrieve the value of y ## [1] 123 The pair of characters &lt;- is the classic symbol used for variable assignment in R. The use of &lt;- instead of = is often recommended in R style guides: http://adv-r.had.co.nz/Style.html &lt;- and = will work the same if they are both used in the “usual way” (when assigning variables within or outside of a function). One exception, is when used inside a function call. For example, if we use = in the function sd(x): sd(x = c(1,2,3,4,5)) # only sets the argument x in sd(x) to (1,2,3,4,5) ## [1] 1.581139 #x ## will return an error if we try to print x sd(x &lt;- c(1,2,3,4,5)) # This actually assigns the vector (1,2,3,4,5) to x ## [1] 1.581139 x ## [1] 1 2 3 4 5 However, using something like sd(x &lt;- c(1,2,3,4,5)) where we assign variables in a function call is not really done that often. It is not common to assign variables in a function call (I never do it). Whenever, using a function f with a keyword such as x, you will generally want to call that function using f(x = ...) So, in my opinion, there is not really a strong reason to prefer using &lt;- over = for assignment. There are other justifications for using &lt;- such as the ability to do assignment from the left by using the reverse symbol -&gt; c(1, 2, 3, 4) -&gt; a # Using c(1,2,3,4) = a will not work! a ## [1] 1 2 3 4 1.2.3 Types of variables Variables can be used to store different types of values. Common types include numeric, text, and logical values. x &lt;- 3.2 x ## [1] 3.2 Here, x is actually a vector (basically a collection of elements storing the same type of data). It is a vector of length one (i.e., it only has one element). This is the reason why you see [1] printed out next to the number 3.2. This means that the first element of the vector x is \\(3.2\\). R treats every variable as some type of collection (e.g., vectors, matrices, lists, etc.). There are no separate data types in R for individual numbers. The elements in a vector can have different types (or modes). You can find the types of the elements in a vector by using the function typeof y &lt;- sqrt(1743) typeof(y) # double and integer are the two numeric types ## [1] &quot;double&quot; z &lt;- 3 # R automatically treats every number as double z ## [1] 3 typeof(z) ## [1] &quot;double&quot; The other common types for the elements in a vector include logical (TRUE or FALSE) values character basically text, e.g., “hello”, “car”, … y &lt;- TRUE typeof(y) ## [1] &quot;logical&quot; z &lt;- &quot;dog&quot; # to define a character variable, place it inside quotes typeof(z) ## [1] &quot;character&quot; We will discuss these types in more detail later on when we discuss vectors, matrices, and lists. 1.3 R Operations with numbers As we mentioned before, … Operator Meaning Example Result + addition 5 + 8 13 - subtraction 90 - 10 80 * multiplication 4 * 7 28 / division 7 / 2 3.5 %% remainder 7 %% 2 1 ^ exponent 3 ^ 4 81 ** exponent 3 ** 4 81 R operations with numbers have similar precedence rules to arithmetic operations Operator Description Precedence +, - addition and subtraction low *, /, %% multiplication, division, remainder … **, ^ exponentiation … (expressions…) Parenthesis high Examples of operation precedence can be seen when typing the following expressions into the R console: 1 + 2 *3 ^ 4 # power &gt; mult/div &gt; add/sub ## [1] 163 (1 + 2 ) *3 ^ 4 # parenthesis &gt; power ## [1] 243 1.4 Brief intro to vectors in R 1.5 Exercises Compute the number \\[\\begin{equation} \\frac{\\sqrt{1.43 + 5^{1.2}}}{3} \\end{equation}\\] directly in the R console. Write an R script that assigns the value … \\[\\begin{equation} \\ln\\Big( 1 + \\exp(-2^{1.4}) \\Big) + \\ln\\Big(1 + 2\\exp(3^{1.7}) \\Big) \\end{equation}\\] to a variable named x and prints the result in the Console when you run the script. Which of the following is NOT a valid variable name in R? .independent_variable3 _independent_variable3 independent_variable3 independent.variable3 "],["ifelse.html", "Chapter 2 Logical Expressions and If-Else Statements in R 2.1 Logical Expression in R 2.2 If and If-else statements 2.3 if-else statements 2.4 Exercises", " Chapter 2 Logical Expressions and If-Else Statements in R 2.1 Logical Expression in R A Logical expression is an expression that evaluates to either TRUE or FALSE. The following are examples of logical expressions in R: 4 &gt; 2 3 &lt;= 5 15.0 + 1.3*1.3 &gt; 17.0 \"cat\" == \"dog\" Each of the above expressions will evaluate to either TRUE or FALSE if you run them in R. 4 &gt; 2 ## [1] TRUE 3 &lt;= 5 ## [1] TRUE 15.0 + 1.3*1.3 &gt; 17.0 ## [1] FALSE x &lt;- &quot;cat&quot; == &quot;dog&quot; # assign to the variable x the value # returned by this logical expression x ## [1] FALSE Most logical expressions are constructed by using some combination of: Comparison operators (&lt;, &lt;=, ==, !=) Logical operators (and, or, not) (in R: &amp;&amp;, ||, !) 2.1.1 Comparison Operators Operator Meaning Example Result &lt; Less than 5 &lt; 3 FALSE &gt; Greater than 5 &gt; 3 TRUE &lt;= Less than or equal to 3 &lt;= 6 TRUE &gt;= Greater than or equal to 4 &gt;= 3 TRUE == Equal to 2 == 2 TRUE != Not equal to ‘str’ != ‘stR’ TRUE 2.1.2 Logical Operators The first main logical operator we will discuss is the logical AND In R, the logical operator &amp;&amp; is used to represent the logical AND The logical AND is used to test whether or not two statements are both true. For two logical expressions A and B, the logical expression A &amp;&amp; B is true only if both A and B evaluate to true. 4 &gt; 2 &amp;&amp; 5/2 == 1 ## only the first statement is TRUE ## [1] FALSE 4 &gt; 2 &amp;&amp; &quot;car&quot; == &quot;truck&quot; ## only the first statement is TRUE ## [1] FALSE 4 &gt; 2 &amp;&amp; 3 &lt; 5 ## both statements are TRUE ## [1] TRUE The logical operator || is used in R to represent the logical OR. For two Boolean expressions A and B, the Boolean expression A || B is true if at least one of A and B evaluates to true. Note that if A and B are both true, A || B will be true; or does not mean only one of A and B is true. 4 &gt; 2 || 5/2 == 1 ## only the first statement is TRUE ## [1] TRUE 4 &gt; 2 || &quot;car&quot; == &quot;truck&quot; ## only the first statement is TRUE ## [1] TRUE 4 &gt; 2 || 3 &lt; 5 ## both statements are TRUE ## [1] TRUE The logical operator ! is used to represent the logical NOT. If the logical expression A is true, then ! A is false. !4 &gt; 2 ## [1] FALSE !4 &gt; 2 &amp;&amp; 3 &gt; 1 ## !4 &gt; 2 is FALSE ## [1] FALSE !(!4 &gt; 2 &amp;&amp; !3 &gt; 1) ## expression in parentheses is evaluated first ## [1] TRUE Note that we can apply logical operations to the keywords TRUE and FALSE themselves: TRUE &amp;&amp; FALSE ## logical AND ## [1] FALSE TRUE || FALSE ## logical OR ## [1] TRUE !TRUE ## logical NOT ## [1] FALSE The below table summarizes the logical operations discussed. Operator Meaning Example Result ! Logical NOT !TRUE FALSE !FALSE TRUE &amp;&amp; Logical AND FALSE &amp;&amp; FALSE FALSE TRUE &amp;&amp; FALSE FALSE FALSE &amp;&amp; TRUE FALSE TRUE &amp;&amp; TRUE TRUE || Logical OR FALSE || FALSE FALSE TRUE || FALSE TRUE FALSE || TRUE TRUE TRUE || TRUE TRUE 2.1.3 Precedence with logical operations Operators Meaning Precedence &amp;&amp;, ||, ! Boolean operators Low +, - Addition and subtraction *, /, %% Multiplication, division, remainder **, ^ Exponentiation (expressions …) Parenthesis High Mathematical operations are generally performed before logical operations. 4 + 2 &gt; 5 ## [1] TRUE 4 + 2 == 6 ## [1] TRUE 2.1.4 Abbreviating TRUE and FALSE with T and F You can use T and F in place of TRUE and FALSE I usually do not use T and F, but you will often see T and F used. T ## T is shorthand for TRUE ## [1] TRUE F ## F is shorthand for FALSE ## [1] FALSE T &amp;&amp; F ## [1] FALSE T || F ## [1] TRUE While you can use T and F in place of TRUE and FALSE, it is good practice to be careful when using these logical abbreviations. T &lt;- 2 ## T is defined as a variable ## Now T represents a vector with T ## a number value, not TRUE ## [1] 2 F ## F still represents FALSE ## [1] FALSE ## FALSE &lt;- 3 # this will result in an error ## TRUE and FALSE cannot be redefined, thus safer to use 2.1.5 Examples of logical operations in R TRUE || FALSE ## boolean OR ## [1] TRUE !TRUE ## NOT operator ## [1] FALSE !TRUE || TRUE ## Which one will get evaluated first? ## [1] TRUE ! (TRUE || TRUE) ## How about this time? ## [1] FALSE 2.1.6 &amp;&amp; vs. &amp; and || vs. | You can also use &amp; for the logical AND operator. You can also use | for the logical OR operator. When comparing logical vectors of length 1: &amp;&amp; and &amp; will return the same thing. || and | will return the same thing. &amp;&amp; vs. &amp; or || vs. | only differ when comparing logical vectors that have lengths longer than 1. TRUE &amp; FALSE ## Same as TRUE &amp;&amp; FALSE ## [1] FALSE TRUE | FALSE ## Same as TRUE || FALSE ## [1] TRUE As an example of the distinction between &amp;&amp; and &amp;, let us define two logical vectors x and y x &lt;- c(TRUE, FALSE, TRUE, FALSE) y &lt;- c(TRUE, TRUE, FALSE, FALSE) x ## [1] TRUE FALSE TRUE FALSE y ## [1] TRUE TRUE FALSE FALSE Let’s see what happens if we then run x &amp;&amp; y and x &amp; y: x &amp;&amp; y ## &amp;&amp; just compares the first two elements ## [1] TRUE x &amp; y ## &amp; returns a vector comparing element-by-element ## [1] TRUE FALSE FALSE FALSE Similarly, let’s see what happens when we run x || y vs. x | y: x || y ## || just compares the first two elements ## [1] TRUE x | y ## | returns a vector comparing element-by-element ## [1] TRUE TRUE TRUE FALSE !x ## [1] FALSE TRUE FALSE TRUE 2.2 If and If-else statements 2.2.1 if statements In R, the form of an if statement is the following: if( condition ) { code_chunk1 } condition is usually a logical expression, but could just be a logical vector of length 1 (i.e., TRUE or FALSE). If condition evaluates to TRUE, code_chunk1 will be executed. You actually do not have to indent the code in code_chunk1, but I would recommend that you do indent. The code inside {…} will be executed only if the condition of the if statement is TRUE. if (TRUE) { # if condition is TRUE &quot;hello&quot; # this statement will run } ## [1] &quot;hello&quot; if (FALSE) { # if condition is FALSE &quot;world&quot; # this statement will NOT run } 2.2.2 if statement examples x &lt;- 1 y &lt;- 2 if (x &lt; y ) { &quot;x is smaller than y&quot; } ## [1] &quot;x is smaller than y&quot; if (x &gt; y ) { &quot;x is greater than y&quot; } x &lt;- 3 y &lt;- 2 if (x &lt; y ) { &quot;x is smaller than y&quot; } if (x &gt; y ) { &quot;x is greater than y&quot; } ## [1] &quot;x is greater than y&quot; if( 2 &lt; 3 ) { &quot;Hello&quot; } ## [1] &quot;Hello&quot; if( &quot;dog&quot; == &quot;cat&quot; ) { &quot;Hello&quot; } d = 2 if( d &lt; 3 &amp;&amp; d == 2.5) { &quot;Hello&quot; } if( 2 &lt; 3 || 2 == 2.5) { &quot;Hello&quot; } ## [1] &quot;Hello&quot; 2.2.3 Single-line if statements If the code to be executed in the if statement is short, you can write it immediately after if(condition) on the same line. Or, you can write the single-line statement on the line immediately below if(condition) x = 5 if(x &gt; 4 &amp; TRUE) x = 2*x # multiply x by 2 x ## [1] 10 This single-line if statement is the same as using: x = 5 if(x &gt; 4 &amp; TRUE) { x = 2*x # multiply x by 2 } x ## [1] 10 2.3 if-else statements In many cases, you want to perform an action if a condition is true but perform another action if that condition is false. This can be done with an if-else statement. In R, the form of an if-else statement is the following: if( condition ) { code_chunk1 } else { code_chunk2 } As with if statements, condition is usually a logical expression, but could just be a logical vector (with a single element). If condition evaluates to TRUE, code_chunk1 will be executed. Otherwise, if condition evaluates to FALSE, code_chunk2 will be executed. As an example, let’s write an if-else statement that computes the absolute value of a number. x &lt;- -3.2 if( x &gt; 0 ) { abs_x &lt;- x # assign the variable abs_x the # value stored in x } else { abs_x &lt;- -x # assign the variable abs_x the # negative of the value stored in x } abs_x # print the value stored in abs_x ## [1] 3.2 Another if-else example: x &lt;- 5 if( x%%2 == 0 ) { # arithmetic operation x%%2 evaluated first &quot;Hello&quot; } else { &quot;world&quot; } ## [1] &quot;world&quot; Another if-else example: x &lt;- 5 if( x%%2 == 0 | x &gt; 4) { &quot;Hello&quot; } else { &quot;world&quot; } ## [1] &quot;Hello&quot; 2.3.1 if-else-if chains In many cases, a desired computation will depend on more than 2 conditions. For these cases, you can use an if - else if - else chain of conditional statements. The general syntax for an if - else if - else chain in R is: if ( condition1 ) { ## If condition1 is TRUE, code_chunk1 ## code_chunk1 will be executed. } else if ( condition2 ) { ## If condition1 is FALSE ## and condiiton2 is TRUE, code_chunk2 ## code_chunk2 will be executed } else if ( condition3 ) { ## If both conditions 1 and 2 are FALSE ## and condition3 is TRUE, code_chunk3 ## code_chunk3 will be executed } . . } else { ## If all previous conditions are FALSE, else_chunk ## else_chunk will be executed } An if-else if-else example: x = 2 if ( x &lt; 0 ) { ## If the condition is TRUE, &quot;x is negative&quot; ## this statement will run. } else if ( x == 0 ) {## If previous conditions are FALSE but this &quot;x is zero&quot; ## is TRUE, this statement will run. } else { ## If previous conditions are FALSE, &quot;x is positive&quot; ## this statement will run. } ## [1] &quot;x is positive&quot; Another if-else if-else example: message &lt;- &quot;second&quot; if ( message == &quot;first&quot; ) { &quot;hello&quot; } else if ( message == &quot;second&quot; ) { &quot;world&quot; } else { &quot;nothing&quot; } ## [1] &quot;world&quot; Be careful about the location of else in if-else if-else statements In R, you do not want to start a line with else if or else. 2.3.2 Nested if-else statements You can certainly have if-else statements within a conditional statement. x = 3 if ( x %% 2 == 0 ) { ## first condition if ( x &lt; 0) { ## second condition &quot;x is even and negative&quot; } else { &quot;x is even and non-negative&quot; } } else if ( x &lt; 0 ) {## this if statement is not nested &quot;x is odd and negative&quot; } else { ## not nested either &quot;x is odd and non-negative&quot; } ## [1] &quot;x is odd and non-negative&quot; 2.4 Exercises What will be printed to the screen if you run the R code below? x &lt;- 2 if(3 &lt; 2 || TRUE) { x &lt;- 2*x } else { x &lt;- 0 } print(x) "],["functions.html", "Chapter 3 Functions in R 3.1 Built-in R functions 3.2 Construction your own R functions 3.3 Default argument values in functions 3.4 Specifying function arguments with keywords 3.5 Exercises", " Chapter 3 Functions in R A function in R can be thought of as a sequence of statements that takes some input, uses that input to compute something, and then returns a result. Why do we need functions? To modularize a task so that we can reuse the same code in many places. To increase readability of code. To reduce redundancy and reduce the number of errors. 3.1 Built-in R functions base R has many useful built-in functions that you can use. Other R packages are another source of useful functions. R’s base package is loaded by default. A few other packages including graphics, stats, and *utils are usually loaded by default as well. The base package includes many widely-used functions, such as the []print() or the sum() function. There are many other R packages available which contain many useful functions. 3.2 Construction your own R functions You can write your own functions as needed. While base R and the many available R packages have a wide range of useful functions, being able to write your own functions gives you much greater flexibility when working with R. 3.2.1 Function Definition Syntax There are three key components of a function definition in R. Function name: the name which will be used to call the function Function arguments: values to pass to a function as input. Return value: the value returned by a function as output. The general syntax for writing your own R function is: function_name &lt;- function(params){ ## function_name is the name of the function ## params name of the input variable within this function statement1 ## statements executed when the function is called statement2 ## statements convert params into some value to be ... ## returned return(return_value) ## return the variable return_value } 3.2.2 Example 1 Let’s write a function that takes a number as an input and returns the square of that number. ## define a new function named square square &lt;- function(x) { ## function name: square, argument : x return(x*x) ## returns x*x } Once we have defined square, we can use it as many times as we would like. After defining the function, each time the function is used is referred to as calling the function. Let’s try calling square with an input number of 10: square(10) ## example of using the function square ## [1] 100 3.2.3 Example 2 Let’s write another function that takes a single number (assumed to be an integer) as input and outputs another number according to the following rule: + if the input number is positive and even, return the number 2 + if the input number if positive and odd, return the number 1 + if the input number is not positive and even, return the number -2 + if the input number if not positive and odd, return the number -1 PositiveEven &lt;- function(x) { if( x &gt; 0 &amp;&amp; x%%2==0 ) { return_value &lt;- 2 } else if( x &gt; 0 &amp;&amp; x%%2==1 ){ return_value &lt;- 1 } else if( x &lt;= 0 &amp;&amp; x%%2==0) { return_value &lt;- -2 } else { return_value &lt;- -1 } return( return_value ) } Now, let’s look at a few examples of calling PositiveEven: PositiveEven(3) ## [1] 1 PositiveEven(-6) ## [1] -2 PositiveEven(0) ## [1] -2 PositiveEven(4) ## [1] 2 We could make our function PositiveEven a bit more user-friendly by having our function throw an error whenever the user inputs a number that is not an integer. PositiveEvenSafe &lt;- function(x) { # Function named PositiveEvenSafe if( x%%1 != 0) { # x%%1 will equal 0 if x is an integer stop(&quot;x must be an integer&quot;) # The stop function will stop the execution # of the function and will return an error } if( x &gt; 0 &amp;&amp; x%%2==0 ) { return_value &lt;- 2 } else if( x &gt; 0 &amp;&amp; x%%2==1 ){ return_value &lt;- 1 } else if( x &lt;= 0 &amp;&amp; x%%2==0) { return_value &lt;- -2 } else { return_value &lt;- -1 } return( return_value ) } Now, let’s see what happens if we call the function PositiveEvenSafe with the argument x = 2 and then x = 7.1 PositiveEvenSafe(2) ## [1] 2 PositiveEvenSafe(7.1) Error in PositiveEvenSafe(7.1) : x must be an integer 3.2.4 Rules for choosing function names All the same rules for variable names apply to rules for choosing function names. Examples of valid and invalid function names include: Valid_Function_Names Invalid_Function_Names i 2things my_function location@ answer42 _user.name .name .3rd Another rule to keep in mind is that you cannot use a reserved word as a function name or variable name. You can use built-in function names (for example, the print function) for your own functions, but this is NOT RECOMMENDED. The following are the reserved words in R: if else while function for in next break TRUE FALSE NULL Inf NA NA_integer NA_real NA_complex NA_character You can find the list of reserved words in R by typing ?reserved directly in the R console 3.3 Default argument values in functions We can provide default values for function parameters/arguments by adding = default_value after the parameter If an argument is specified in the function call, the specified one is used Otherwise; the default argument value is used In the function definition, it is generally better (though not required) to put parameters without default arguments before those with default arguments. When calling a function, arguments must be specified for every parameter without default arguments. Unlike Python, in R you can mix arguments with/without default arguments in an arbitrary order (though I don’t recommend it). 3.3.1 Example 1 As an example, let’s write a function that adds 3 numbers and, as a default, sets one of these numbers to zero: add3 &lt;- function(x, y, z=0) { return(x + y + z) } The default value for z here is \\(0\\). add3(1, 2) ## omit z ## [1] 3 add3(1, 2, 0) ## this should give the same as add3(1,2) ## [1] 3 add3(1, 2, 3) ## set z to 3 instead of 0 ## [1] 6 3.4 Specifying function arguments with keywords We can specify how arguments are passed to parameters not only by their order but by names with keyword arguments. Keyword arguments: have to do with how you call a function - not with the function definition itself. For example, we could call our function add3 with keywords in the following way: add3(2, 2, 1) # Call function using original positions ## [1] 5 add3(x=2, y=2, z=1) # Call function using keywords ## [1] 5 add3(y=2, x=2, z=1) # With keywords, position does not matter ## [1] 5 3.4.1 Example 1 The function foo below has parameters x, y,, z, w. The default value of z is \\(0\\), and the default value of w is TRUE. foo &lt;- function (x, y, z=0, w=TRUE) { if(w) { 1000*x + 100*y + 10*z ## this is equivalent to return(...) } else { 1000*x - 100*y + 10*z } } Let’s try calling foo using the original position of the arguments in the function definition. foo(9, 3, 5,TRUE) ## specify all arguments ## [1] 9350 foo(9, 3, 5) ## omit argument w ## [1] 9350 foo(9, 3) ## omit both z and w ## [1] 9300 Now, let’s try calling foo using keyword arguments and change the orders of x and y. ## foo(9) ## this will cause error because y is unknown foo(x=9, y=5) ## specify x and y as keyword arguments ## [1] 9500 We can even switch the positions of x and y when using keyword arguments foo(y=5, x=9) ## when using keywords, argument order doesn&#39;t matter ## [1] 9500 You can even mix which arguments you specify as positional and keyword: foo(9, y=5) ## specify x as positional, y as keyword argument ## [1] 9500 foo(9, z=3, y=5) ## y,z are keyword arguments, x is positional ## [1] 9530 3.5 Exercises Suppose we define the function quiz as quiz &lt;- function(bool_var1, x=0, bool_var2 = TRUE) { y &lt;- 0 if(bool_var1 &amp;&amp; bool_var2) { y &lt;- x + 2 } else { if(bool_var1) { y &lt;- x - 2 } } return(y) } What value does the following function call return? quiz(FALSE, 1.3) Write an R function that implements the following mathematical function in R \\[\\begin{equation} L(x, y) = \\begin{cases} 0 &amp; \\text{ if } x = 0 \\text{ and } y = 0 \\nonumber \\\\ 1 &amp; \\text{ if } x \\neq 0 \\text{ and } y = 0 \\nonumber \\\\ |x| &amp; \\text{ if } y = 1 \\nonumber \\\\ x^{2} &amp; \\text{ if } y = 2 \\nonumber \\end{cases} \\end{equation}\\] The function should have user-provided arguments x and y and should return NA if y does not equal either \\(0\\), \\(1\\), or \\(2\\) Write an R function called PropGtZero which returns the proportion of three entered numbers which are greater than \\(0\\). The function should have the following function definition PropGtZero &lt;- function(x, y, z, gt=TRUE) { } If gt=TRUE, then PropGtZero should return the proportion of the numbers x, y, z which are greater than \\(0\\). If gt=FALSE, then PropGtZero should return the proportion of the numbers x, y, z which are lesser than or equal to \\(0\\). If one or more of x, y, z, is NA, the function should return NA. For example, PropGtZero(3,2,-2) should return \\(2/3\\). "],["loops.html", "Chapter 4 Loops in R 4.1 For Loops 4.2 While Loops 4.3 Exercises", " Chapter 4 Loops in R Loops are typically used when we want to repeat some type of calculation many times. The two types of loops in R are the for loop and the while loop. For loops: Typically used when we know exactly how many times we need to repeat a calculation. While loops: Typically used when we only want to repeat some calculation until some condition is satisfied. 4.1 For Loops The general form of a for loop in R is for (x in vec_name) { perform a calculation (often involving x) } The for loop will execute the code underneath the for statement \\(T\\) times where \\(T\\) is the length of the vector vec_name. Each time the code is executed, x will be set to one element in vec_name. 4.1.1 Example 1: printing the first 5 integers As an example, let’s write a for loop that prints the first 5 positive integers: for (k in 1:5) { print(k) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 Each time you go inside the loop, the variable k takes the next value in the vector 1:5 and is printed to the screen. 4.1.2 Example 2: computing 10 factorial As another example, let’s use a for loop to compute the product \\[\\begin{equation} 10! = 1 \\times 2 \\times 3 \\times ... \\times 9 \\times 10 \\nonumber \\end{equation}\\] prod_ten &lt;- 1 # start from 1 for(x in 2:10) { # iterate x from 1 thru 10 prod_ten &lt;- prod_ten*x # multiply each value } print(prod_ten) # print the product of first 10 integers ## [1] 3628800 4.1.3 Example 3: a non-numeric looping variable The looping variable does not need to be numeric. Here is an example where the looping variable has character type. fruits &lt;- c(&quot;apple&quot;,&quot;orange&quot;,&quot;grape&quot;) # character vector for(fruit in fruits) { # iterate each element print(fruit) } ## [1] &quot;apple&quot; ## [1] &quot;orange&quot; ## [1] &quot;grape&quot; 4.1.4 Example 4: first Fibonacci numbers The Fibonacci sequence is a sequence of numbers \\(x_{1}, x_{2}, x_{3}, ...\\) defined by the relationship: \\[\\begin{equation} x_{k} = x_{k-1} + x_{k-2} \\nonumber \\end{equation}\\] The first two numbers in the Fibonacci sequence are \\(x_{1} = 0\\) and \\(x_{2} = 1\\). We want to write R code that stores the first \\(n\\) Fibonacci numbers in a vector. To do this, it is more efficient to first create a vector of zeros and then fill in the Fibonacci numbers into this vector. This is done by first assigning x the vector rep(0, n) ## R code for computing first 12 Fibonacci numbers x &lt;- rep(0, 12) # First initialize a vector of size 12 x[1] &lt;- 0 x[2] &lt;- 1 for(k in 3:12) { ## start at index 3 since first 2 elements are filled in x[k] &lt;- x[k-1] + x[k-2] } x ## [1] 0 1 1 2 3 5 8 13 21 34 55 89 You could create a vector of the first \\(n\\) Fibonacci numbers by “appending” an extra number to the vector x each time we go in the loop. This is usually much slower than first initializing a vector as was done on the previous slide. ## R code for computing first 12 Fibonacci numbers x &lt;- c(0, 1) for(k in 3:12) { x &lt;- c(x, x[k-1] + x[k-2]) } x ## [1] 0 1 1 2 3 5 8 13 21 34 55 89 4.1.5 Nested for loops You can have a for loop within another for loop. These are usually referred to as nested for loops. for (i in 1:3) { # i iterates over 1,2,3 for (j in 1:i) { # j iterates over 1 to i print(c(i,j)) } } ## [1] 1 1 ## [1] 2 1 ## [1] 2 2 ## [1] 3 1 ## [1] 3 2 ## [1] 3 3 4.1.6 break and next: Exiting for loops and skipping iterations You can use the break statement to terminate a loop. The for loop will be stopped whenever the statement break is encountered. As an example of this, let’s write a loop that should run for 5 iterations, but is terminated after during it’s 3rd iteration. for(k in 1:5) { print(k) if(k &gt;= 3) { break ## loop will stop when break is run } } ## [1] 1 ## [1] 2 ## [1] 3 Note that if we move the print statement after break in the above example, then only 1 and 2 will be printed to the screen. for(k in 1:5) { if(k &gt;= 3) { break ## loop will stop when break is run } print(k) } ## [1] 1 ## [1] 2 break statements can be used within nested loops. If using a break statement in the inner loop of a nested loop, only the inner loop will be terminated when break is run. for (i in 1:3) { # i iterates over 1,2,3 for (j in 1:3) { # j iterates over 1,2,3 print(c(i,j)) if (j == i) { ## if j and i are the same break ## finish the inner loop } } } ## [1] 1 1 ## [1] 2 1 ## [1] 2 2 ## [1] 3 1 ## [1] 3 2 ## [1] 3 3 The next statement is used to skip the remainder of a current iteration. When the next statement is encountered, you will go directly to the next iteration and not execute whatever was remaining inside the body of the for loop. Let’s try an example where we have 5 iterations setup, but we use a next statement within the 3rd iteration for(k in 1:5) { if(k == 3) { next } print(k) # this will not print when k==3 } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 5 next can also be used within a nested loop. If used in an inner loop, the next statement will skip the remainder of the current inner loop iteration and go to the next inner loop iteration. for (i in 1:3) { # i iterates over 1,2,3 for (j in 1:3) { # j iterates over 1,2,3 if (j == i) { ## if j equals i next ## go to next iteration } ## of inner loop print(c(i,j)) } } ## [1] 1 2 ## [1] 1 3 ## [1] 2 1 ## [1] 2 3 ## [1] 3 1 ## [1] 3 2 4.2 While Loops For loops execute a piece of code a set number of times. While loops keep executing the piece of code as long as a certain condition is TRUE. The general form of a while loop in R is while(condition) { code chunk then, usually update something related to condition } condition is a logical expression. The code_chunk inside the loop is repeated until the condition becomes FALSE in which case the loop stops. Basic example of while loop: prod &lt;- 1 # start from 1 while(prod &lt; 100) { # repeat the block until condition is true print(prod) # print the value of prod prod &lt;- prod * 2 # and double the value } ## [1] 1 ## [1] 2 ## [1] 4 ## [1] 8 ## [1] 16 ## [1] 32 ## [1] 64 4.2.1 Example 1: a “first which” function We can use a while loop to find the first occurrence of a number in a vector. Specifically, for an input vector x and input number num, we want to find the first index k such that x[k] == num This function will also return NA if no match is found. first_while &lt;- function(x, num) { index.count &lt;- 0 match.not.found &lt;- TRUE while(match.not.found &amp;&amp; index.count &lt; length(x)) { # want to keep loop running while match is not found # and the index is less than the length of x index.count &lt;- index.count + 1 match.not.found &lt;- !(x[index.count] == num) } if(match.not.found) { index.count &lt;- NA } return(index.count) } Let’s try running first_while on a few examples: first_while(1:5, 3) ## [1] 3 first_while(1:5, 6) ## [1] NA first_while(1:5, 5) ## [1] 5 first_while(rep(1:3, each=4), 2) ## [1] 5 4.3 Exercises "],["vectors.html", "Chapter 5 Vectors 5.1 Creating vectors in R 5.2 Subsets of vectors 5.3 Useful methods for vectors 5.4 Vectors with different data types 5.5 Mathematical operations with vectors 5.6 Set operations with vectors 5.7 NA and is.na(): missing values in R 5.8 Exercises", " Chapter 5 Vectors The most basic data type in R is the vector. As we mentioned previously, if we assign the number 42 to a variable named x, R will treat x as a vector. x &lt;- 42 ## the x value is 42 x ## print the value of x ## [1] 42 x[1] ## What does this do? ## [1] 42 Here, x is considered to be a vector of length 1. Technically, there are two kinds of vectors in R: atomic vectors lists However, it is very common to refer to atomic vectors as simply “vectors” and to refer to lists as “lists”. Vectors that are homogenous (all elements have the same type) are technically referred to as atomic vectors in R. It is common to refer to any atomic vector as a vector. We will also refer to any atomic vector as a vector. R will always store data as a “collection”. Dimension Homogeneous Heterogeneous 1-Dimension Atomic Vector List 2-Dimensions Matrix Data Frame &gt;2-Dimensions Multi-dimensional array There is no “0-dimensional data” in R. Even a single-valued object is considered to be a “vector” with length 1. Source: http://adv-r.had.co.nz/Data-structures.html 5.1 Creating vectors in R 5.1.1 The concatenate function c() The most straightforward way to create vectors in R is to use the concatenate function c() This links together a group of values into a single vector. You can also create a single vector from multiple vectors using c. Examples of using c() to create numeric vectors are: x &lt;- c(1,2,3) # create a length-3 vector with elements 1, 2, and 3 x ## [1] 1 2 3 y &lt;- c(x, 4, 5) # create a vector with elements 1,2,3,4,5 y ## [1] 1 2 3 4 5 You are not limited to using numeric values with c(). For example, you can use c() to create a vector of characters or logicals. char_vec &lt;- c(&quot;cat&quot;, &quot;dog&quot;, &quot;hamster&quot;) # vector of characters char_vec ## [1] &quot;cat&quot; &quot;dog&quot; &quot;hamster&quot; log_vec &lt;- c(TRUE, FALSE, TRUE, TRUE) # vector of logicals log_vec ## [1] TRUE FALSE TRUE TRUE 5.1.2 colon, seq, rep: Creating vectors with specific patterns It is often very useful to be able to create vectors with specific patterns. The colon operator : can be used to create a sequence of numbers. The code from:end will create a vector of numbers starting at from and increasing (or decreasing) by 1 until reaching end. Examples: x &lt;- 1:5 # creates the vector (1,2,3,4,5) x ## [1] 1 2 3 4 5 y &lt;- 22:28 y ## [1] 22 23 24 25 26 27 28 You can also use the colon operator to create a decreasing sequence of numbers. z &lt;- 0:-5 # use : to created decreasing vector z ## [1] 0 -1 -2 -3 -4 -5 You can even have use a number with a decimal point as the starting or ending number (but this is not done that frequently). w &lt;- 2.3:6.8 # it keeps increasing by 1 until it reaches # largest value less than 6.8 w ## [1] 2.3 3.3 4.3 5.3 6.3 Be careful when using something like a:b-1 when creating a vector b &lt;- 6 u &lt;- 1:b - 1 # This does not create the vector 1,2,...,b-1 u ## [1] 0 1 2 3 4 5 u &lt;- 1:(b-1) # use this to create vector 1,2,...,b-1 u ## [1] 1 2 3 4 5 The function seq is a useful function for creating vectors that have desired starting and ending values. seq provides more flexibility than the colon operator : You can use seq to create a sequence with different increments than \\(1\\) seq(1, 11, by=2) # sequence that increases by 2 ## [1] 1 3 5 7 9 11 seq(1, 10, by=2) # stops at 9 since 11 is larger than 10 ## [1] 1 3 5 7 9 seq(1, 11, by=2.54) # increment by non-integer amount ## [1] 1.00 3.54 6.08 8.62 Use the length.out argument in seq to create an equally-spaced vector with a given length. seq(1, 11, length.out=11) # same as 1:11 ## [1] 1 2 3 4 5 6 7 8 9 10 11 seq(1, 11, length.out=6) # vector of length 6, with equal increments ## [1] 1 3 5 7 9 11 # using length.out is convenient seq(21.5, 48.2, length.out=5) # don&#39;t have to work out correct increments ## [1] 21.500 28.175 34.850 41.525 48.200 The rep() (replicate) function is very useful for creating vectors that have any kind of repeated pattern. The basic form of rep is rep(x, times) rep produces a vector which repeats the vector x times number of times. rep(7, 3) # just creates the vector 7,7,7 ## [1] 7 7 7 rep(c(2,4,6), 3) # repeats c(2, 4, 6) three times ## [1] 2 4 6 2 4 6 2 4 6 Using rep inside of c(): c(10:12, rep(c(2,4,6), 3)) ## [1] 10 11 12 2 4 6 2 4 6 2 4 6 Using rep with the keyword each will repeat each element of x each times before moving on to the next element of x. rep(c(2,4,6), each=4) # repeat each element 4 times ## [1] 2 2 2 2 4 4 4 4 6 6 6 6 5.2 Subsets of vectors 5.2.1 Extracting vector elements You can extract the \\(k^{th}\\) element of a vector by using vector_name[k] For example: x &lt;- c(1,3,5,100) x[2] # second element of x ## [1] 3 x[4] # fourth element of x ## [1] 100 You can also extract a subset of elements with indices stored by the vector vec_index from a vector by using vector_name[ vec_index ] For example: x &lt;- c(1,3,5,100, 1250) x[ c(1,3) ] # extract first and third elements of x ## [1] 1 5 x[ 3:5 ] # extract elements 3 through 5 of x ## [1] 5 100 1250 You can change the value of the \\(k^{th}\\) element of a vector by using vector_name[k] &lt;- new_value x &lt;- c(1,3,5,100) x[2] &lt;- 6 # you may update a single element print(x) ## [1] 1 6 5 100 You can also update multiple elements of a vector by placing a vector of indices inside brackets [] x[1:3] &lt;- rep(10,3) # update first 3 elements of x print(x) ## [1] 10 10 10 100 5.2.2 Subsetting with logical expressions We described above how you can take a subset of a vector by specifying the vector indeces that you want for your subset. You can also subset a vector using a logical expression rather than explicitly specifying the indeces you want. x &lt;- c(10, 2, 21, 15) y &lt;- x[x &gt; 8] # returns all elements of x greater than 8 z &lt;- x[x &gt; 12] # returns all elements of x greater than 12 y ## [1] 10 21 15 z ## [1] 21 15 You can think of the expression x[x &gt; 8] as doing the following: x[c(TRUE, FALSE, TRUE, TRUE)] ## [1] 10 21 15 5.2.3 The which function You can find the indeces of a vector that satisfy a certain condition using the which function. x &lt;- c(10, 2, 21, 15) which(x &gt; 20) # shows that x[3] &gt; 20 ## [1] 3 which(x &gt; 12) # shows that x[3] &gt; 12 and x[4] &gt; 12 ## [1] 3 4 The which function really just returns the indeces where a logical vector is TRUE which( c(FALSE, TRUE, FALSE) ) ## [1] 2 5.3 Useful methods for vectors The length function can tell you how many elements are in your vector: x &lt;- 9:0 x ## [1] 9 8 7 6 5 4 3 2 1 0 length(x) # length of the vector ## [1] 10 typeof(x) # type of elements ## [1] &quot;integer&quot; sum(x) # sum of values ## [1] 45 R has functions which allow you to compute all the well-known summary statistics from a numeric vector. x &lt;- 1:5 mean(x) # average of vector elements ## [1] 3 var(x) # variance (denominator is n-1) ## [1] 2.5 sd(x) # standard deviation (denominator is n-1) ## [1] 1.581139 x &lt;- 1:5 max(x) # maximum value ## [1] 5 min(x) # minimum value ## [1] 1 median(x) # median ## [1] 3 5.4 Vectors with different data types As we mentioned before, R vectors are not limited to having numeric elements. The main restriction for vectors is that they must have elements which are all the same type. x &lt;- c(1, 2.5, 42) ## numeric vector print(x) ## [1] 1.0 2.5 42.0 y &lt;- c(&quot;hello&quot;,&quot;world&quot;,&quot;biostat607&quot;) ## character vectors print(y) ## [1] &quot;hello&quot; &quot;world&quot; &quot;biostat607&quot; z &lt;- c(TRUE, FALSE, FALSE) ## logical vectors print(z) ## [1] TRUE FALSE FALSE You can “create” a vector that has mixed data types, but R will automatically convert the types of some of the elements so that all elements have the same type. x &lt;- c(TRUE, FALSE, FALSE) ## homogeneous logical vector print(x) ## [1] TRUE FALSE FALSE x &lt;- c(TRUE, FALSE, 2) ## contains logical and numeric values print(x) ## R translates logical TRUE/FALSE into numeric 1/0 ## [1] 1 0 2 x &lt;- c(1, 2, &quot;3&quot;) ## numeric + character print(x) ## R translates numeric values translates into characters ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; x &lt;- c(TRUE, 2, &quot;3&quot;) ## logical + numeric + character print(x) ## R translates logical and numeric values into characters ## [1] &quot;TRUE&quot; &quot;2&quot; &quot;3&quot; 5.4.1 Explicitly changing the data types You can convert a vector to another type using as.logical, as.numeric, or as.character. x &lt;- as.logical(c(0,1,2,3)) # numeric to logical conversion print(x) ## [1] FALSE TRUE TRUE TRUE x &lt;- as.numeric(c(TRUE,FALSE, T,F)) # logical to numeric print(x) ## [1] 1 0 1 0 x &lt;-as.character(c(0,1,2,3)) # numeric to string print(x) ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; Sometimes conversion of a vector does not work ## When a character cannot be converted, it returns NA ## as an invalid number as.numeric(c(&quot;123&quot;,&quot;12.3&quot;,&quot;123a&quot;)) ## Warning: NAs introduced by coercion ## [1] 123.0 12.3 NA ## Characters cannot be converted into logical values as.logical(c(&quot;TRUE&quot;,&quot;FALSE&quot;, &quot;T&quot;,&quot;TF&quot;,0)) ## [1] TRUE FALSE TRUE NA NA as.integer(c(123, 12.3, &quot;123&quot;, &quot;123a&quot;)) ## Warning: NAs introduced by coercion ## [1] 123 12 123 NA 5.5 Mathematical operations with vectors When doing mathematical operations with two vectors of the same length, R will perform addition, subtraction, multiplication, division element-by-element. x &lt;- c(10, 5, 0) y &lt;- 1:3 x+y # element-wise addition ## [1] 11 7 3 x*y # element-wise multiplication ## [1] 10 10 0 x^y # element-wise power ## [1] 10 25 0 Multiplying or dividing a vector by a single number multiplies (or divides) each element by that number x &lt;- c(10, 5, 0, -5) 3*x ## [1] 30 15 0 -15 x/2 ## [1] 5.0 2.5 0.0 -2.5 Adding or subtracting a vector by a single number also adds (or subtracts) each element by that number x &lt;- c(10, 5, 0, -5) 3 + x # Actually an example of recycling with a one-element vector ## [1] 13 8 3 -2 5.5.1 Recycling rules You can actually add/subtract vectors of different lengths in R. When doing this, R recycles the values in the shorter vector. R will print out a warning message if the length of the longer vector is not a multiple of the shorter vector. Specifically, when R adds two vectors (say a \\(=(a[1], \\ldots, a[n_{a}])\\) and b\\(=(b[1], \\ldots, b[n_{b}])\\)) with lengths \\(n_{a}\\) and \\(n_{b}\\) respectively (with \\(n_{a} &lt; n_{b}\\)), R returns the following sum \\[\\begin{equation} \\sum_{j=1}^{n_{b}} a[((j - 1)\\mod n_{a}) + 1]b[j] \\end{equation}\\] We can see an example of this recycling rule in R when we try to add a vector of length 3 with a vector of length 4: c(1, 2, 4) + c(6, 0, 9, 10) ## Warning in c(1, 2, 4) + c(6, 0, 9, 10): longer object length is not a multiple ## of shorter object length ## [1] 7 2 13 11 You can think of the above code as adding the vector c(1, 2, 4, 1) with the vector c(6, 0, 9, 10). Note that if we add a vector of length 3 with a vector of length 6 we will get no warning message. This is because \\(6\\) is a multiple of \\(3\\). c(1, 2, 4) + c(6, 0, 9, 10, 11, 12) ## [1] 7 2 13 11 13 16 The above code adds the vector c(1, 2, 4, 1, 2, 4) with the vector c(6, 0, 9, 10, 11, 12). I personally do not use recycling rules much when the length of **both vectors* is 2 or more. It’s probably good to be aware of recycling rules if you are getting this type of warning message. You may find it helpful to use these recycling rules if you are, for example, adding one vector with another vector that has a simple, repeating pattern. 5.5.2 Logical operations with vectors You can do AND and OR-type operations with logical vectors. Remember that &amp; acts like a “vector version” of &amp;&amp; Remember that | acts like a “vector version” of || c(TRUE, TRUE, FALSE) &amp; c(TRUE,FALSE,FALSE) # element-wise ## [1] TRUE FALSE FALSE c(TRUE, TRUE, FALSE) | c(TRUE,FALSE,FALSE) # element-wise ## [1] TRUE TRUE FALSE c(TRUE, TRUE, FALSE) &amp;&amp; c(TRUE,FALSE,FALSE) # only first values ## [1] TRUE c(TRUE, TRUE, FALSE) || c(TRUE,FALSE,FALSE) # only first values ## [1] TRUE 5.6 Set operations with vectors You can also do set operations with vectors. When working with set operations, you should think of the set associated with a vector as the collection of unique elements from that vector. For example, consider the vectors x and y defined as x &lt;- c(1,2,3,3,4,5) # x is c (1,2,3,3,4,5) y &lt;- c(1,3,3,5,7,9) # y is c (1,3,3,5,7,9) The “set” associated with x is \\(\\{1,2,3,4,5\\}\\) and the “set” associated with y is \\(\\{1,3,5,7,9\\}\\). Then, the intersection of x and y using the intersect function in R is \\(\\{1, 3, 5\\}\\) intersect(x,y) # set intersection, note that repeated 3 is dropped ## [1] 1 3 5 Similarly, the union function in R computes the “union” of x and y: \\(\\{1,2,3,4,5,7,9\\}\\) union(x,y) # set union ## [1] 1 2 3 4 5 7 9 One can compute the “set difference” of two sets using setdiff. These are the elements that are in x but are not in y. setdiff(x,y) # set difference x - y ## [1] 2 4 The operation x %in% y returns a logical vector the same length as x indicating whether or not each element of x belongs to the set of unique elements of y x %in% y # membership test ## [1] TRUE FALSE TRUE TRUE FALSE TRUE The function match match(x, y) # find indices of first matching values ## [1] 1 NA 2 2 NA 4 5.6.1 The function unique() 5.7 NA and is.na(): missing values in R Missing data in R is usually represented by the value NA. NA stands for “Not Available” You can create a vector with NA values by just typing in NA for one of the vector elements. x &lt;- c(1, 5, NA, 4) # The third element of this vector is NA typeof(x) ## [1] &quot;double&quot; You can type in NA for either numeric or character variables. R will automatically convert everything to the appropriate type. y &lt;- c(&quot;cat&quot;, NA, &quot;dog&quot;) # The second element of this vector is NA typeof(y) ## [1] &quot;character&quot; Many of the built-in R functions will return NA if the input numeric vector contains any NA values. For example, if we try to compute the standard deviation of the vector x x &lt;- c(1, 5, NA, 4, 7) # The third element of this vector is NA mx &lt;- sd(x) # mx will have the value NA mx ## [1] NA You can compute the standard deviation of the non-NA values by including the argument na.rm = TRUE sx &lt;- sd(x, na.rm=TRUE) # sx shoud have the standard deviation of 1,5,4,7 sx ## [1] 2.5 In the function sd, the argument na.rm is a good example of an argument with a default value. You can see that na.rm has a default value by looking at the function definition for sd sd &lt;- function(x, na.rm = FALSE) { } The default value of na.rm is FALSE. So, you need to include na.rm = TRUE if you want sd to ignore missing values. 5.7.1 The function is.na() The function is.na() is often very useful when you’re working with data that has mising values. When applied to a vector, is.na() will return a vector of logical values with the same length as the input vector. The \\(k^{th}\\) element of is.na(x) will be TRUE if the \\(k^{th}\\) element of x is missing. Otherwise, the \\(k^{th}\\) element of is.na(x) will be FALSE. x &lt;- c(10, 3, 5, NA, 1, NA) # Elements 4 and 6 of x have NA values is.na(x) ## [1] FALSE FALSE FALSE TRUE FALSE TRUE You can also use is.na() directly on matrices and data frames. 5.8 Exercises Suppose we define the vector x as x &lt;- 1:10. What is the value of x[ seq(1, 10,by=2)][3]? Suppose x &lt;- rep(c(1, 5, 10), each=3). What is the value of sum( x[x &gt; 5] )? Create a vector called xvec that stores the following sequence of numbers: \\(1, 1, 2, 1, 2, 3, 1, 2, 3, 4, ....\\) and keeps repeating this pattern until the last number is \\(10\\). What is the length of xvec? What number is the \\(35^{th}\\) element of xvec? What is the mean value of the numbers contained in xvec? How many elements of xvec equal \\(2\\)? How many elements of xvec equal \\(7\\)? What is the sum of all the even numbers contained in xvec? "],["matrix.html", "Chapter 6 Matrices 6.1 Creating matrices in R 6.2 Accessing different features of a matrix 6.3 Applying functions to matrices 6.4 Matrix Functionals 6.5 Exercises", " Chapter 6 Matrices A matrix is a table of data organized into rows and columns. \\[\\begin{equation} \\mathbf{A} = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; \\ldots &amp; a_{1p} \\\\ a_{21} &amp; a_{22} &amp; \\ldots &amp; a_{2p} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n1} &amp; a_{12} &amp; \\ldots &amp; a_{np} \\end{bmatrix} \\nonumber \\end{equation}\\] The matrix \\(\\mathbf{A}\\) has \\(n\\) rows and \\(p\\) columns. The matrix element \\(a_{ij}\\) represents the number in the \\(i^{th}\\) row and \\(j^{th}\\) column. R allows the elements of a matrix to be any type. As with vectors, the elements of a matrix in R must all have the same type. 6.1 Creating matrices in R The most common way to create a matrix is with the matrix function. The form of the matrix function is matrix(x, nrow, ncol) x is a vector that you want to convert into a matrix. nrow is the number of rows you want the matrix to have. ncol is the number of columns you want the matrix to have. x could be a single number (a vector of length one) in which case the returned matrix will have all the same entries. If we wanted to create a matrix named A with 2 rows and 3 columns that contains only zeros, we could use the following code A &lt;- matrix(0, 2, 3) A ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 To convert a vector into a matrix Convert the vector (1, 2, 3, 4, 5, 6) into a matrix with 2 rows and 3 columns x &lt;- 1:6 # x is a vector of 1,2,3,4,5,6 B &lt;- matrix(x, 2, 3) # create a matrix from this vector B ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Notice that matrix function fills in the matrix entries by columns (i.e, it fills in the numbers from x in the first column, then moves to the second, etc.) This is referred to as filling in the entries “by column” x &lt;- 1:6 # x is a vector of 1,2,3,4,5,6 B &lt;- matrix(x, 2, 3) # create a matrix from this vector B ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 You can instead fill in the matrix entries by rows by using the keyword argument byrow = TRUE D &lt;- matrix(x, 2, 3, byrow=TRUE) D ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 It is often useful to create a matrix which has all the same columns (or rows): matrix(1:2, 2, 3) # duplicates the column vector c(1,2) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 2 2 2 matrix(1:3, 2, 3) # this does not duplicate the row vector c(1,2,3) ## [,1] [,2] [,3] ## [1,] 1 3 2 ## [2,] 2 1 3 matrix(1:3, 2, 3, byrow=TRUE) # but this one does! ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 1 2 3 6.2 Accessing different features of a matrix 6.2.1 Accessing elements of a matrix To access the \\((i,j)\\) element of a matrix A, use the syntax A[i,j] As an example of this, let’s create a \\(2 \\times 3\\) matrix A and look at the \\((2,1)\\) element of A: A &lt;- matrix(1:6, 2, 3, byrow=TRUE) # creating a 2x3 matrix A # print the matrix ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 A[2,1] ## [1] 4 You can access different subsets of a matrix by using vectors of indeces rather than single numbers in the indexing bracket. For example, if you want to look at elements \\((2, 1)\\) and \\((2,2)\\) of A, you can use the following syntax: A[2,1:2] ## [1] 4 5 Similarly, if you want to access all elements of A in either the first two rows or first two columns of A, you can use the following syntax: A[1:2, 1:2] ## [,1] [,2] ## [1,] 1 2 ## [2,] 4 5 To access the entire kth column of A, use the syntax A[,k]. To access the entire kth row of A, use the syntax A[k,] A[,2] ## access 2nd column of A ## [1] 2 5 Using nrow() or ncol() let you see the number of rows or columns of a matrix. A &lt;- matrix(1:6, 2, 3, byrow=TRUE) # creating a 2x3 matrix nrow(A) ## [1] 2 ncol(A) ## [1] 3 dim will return both the number of rows and columns. dim(A) ## [1] 2 3 While using the A[i,j] syntax is a more typical way of accessing specific elements of a matrix, you can also access the elements of a matrix as you would with a vector. For a matrix, the indexing increases by column For example, if A has 3 rows: A[1]=A[1,1], A[2]=A[2,1], A[3]=A[3,1], A[4]=A[1,2], … For example if we access the “4th” and “5th” elements of a \\(2 x 3\\) matrix A ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 A[4:5] ## accessing like a one-dimensional vector ## [1] 5 3 I don’t really use this way of accessing matrix elements much though, in some cases, it is more convenient (e.g., A[ which(A &gt; 3) ]) You can also access elements of a matrix like a vector using logical subsetting which( A &gt; 3) ## getting indices with which ## [1] 2 4 6 A[ which(A&gt;3) ] ## getting the elements greater than 3 ## [1] 4 5 6 6.2.2 Diagonals of Matrices The diagonals of a matrix are the elements of the matrix where the row index equals the column index. In a diagonal matrix, all non-diagonal elements must be zero. To create a diagonal matrix in R, use the diag function. You must provide the vector of diagonal elements as the input to diag diag(1:4) # 4x4 diagonal matrix with (1,2,3,4) as diagonals ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 2 0 0 ## [3,] 0 0 3 0 ## [4,] 0 0 0 4 If you use diag(A) where the input argument A is a matrix, this will return the diagonal elements of A. A &lt;- matrix (1:9, 3, 3) A ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 diag(A) # returns diagonals of this matrix ## [1] 1 5 9 Working with off-diagonal elements. The function upper.tri(A) returns a logical matrix of the same dimension as A with TRUE values on the “upper diagonal” part of the matrix. Thus, you can use upper.tri to update the upper diagonal parts of a matrix. x &lt;- matrix (1:9, 3, 3) x[upper.tri(x)] &lt;- 0 x ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 2 5 0 ## [3,] 3 6 9 Similarly, lower.tri(A) allows you to look at the subset of entries on the “lower diagonal” part of a matrix. x[lower.tri(x,diag=TRUE)] &lt;- 10:15 x ## [,1] [,2] [,3] ## [1,] 10 0 0 ## [2,] 11 13 0 ## [3,] 12 14 15 6.2.3 Naming rows or columns You can give a name to each row with the rownames function. The collection of row names of a matrix should be a vector. x &lt;- matrix(1:6, nrow=2, ncol=3) rownames(x) &lt;-c(&quot;a&quot;,&quot;b&quot;) x ## [,1] [,2] [,3] ## a 1 3 5 ## b 2 4 6 You can actually access rows of a matrix by name: x[1,] ## [1] 1 3 5 rownames(x) &lt;-c(&quot;a&quot;,&quot;b&quot;) x[&quot;a&quot;,] ## [1] 1 3 5 Similarly, you can access columns of a matrix by name: colnames(x) &lt;-c(&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;) x ## c1 c2 c3 ## a 1 3 5 ## b 2 4 6 x[2, c(2,3)] ## c2 c3 ## 4 6 x[&quot;b&quot;, c(&quot;c2&quot;,&quot;c3&quot;)] ## c2 c3 ## 4 6 6.2.4 Combining rows or columns You can “join” matrices in “vertical” or “horizontal” ways by using the functions cbind (column bind) rbind (row bind) X &lt;- matrix(1:6,2,3) Y &lt;- X^2 cbind(X,Y) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 1 9 25 ## [2,] 2 4 6 4 16 36 rbind(X,Y) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 ## [3,] 1 9 25 ## [4,] 4 16 36 6.3 Applying functions to matrices You can directly use matrices as input arguments with many of the widely-used built-in R functions. Functions like sum or mean will take the sum (or average) of all the elements of a matrix: A &lt;- matrix (1:6, 2, 3) sum(A) # sum of all elements ## [1] 21 mean(A) # average of all elements ## [1] 3.5 sd(A) # standard deviation of all elements ## [1] 1.870829 You can take the transpose of a matrix A using t(A). You can convert a matrix A into a vector using as.vector(A) or simply c(A). A ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 t(A) ## transpose of A (reverse role of rows/columns) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 as.vector( A ) ## convert matrix to vector in column-wise order ## [1] 1 2 3 4 5 6 as.vector( t(A) ) ## convert matrix to vector in row-wise order ## [1] 1 3 5 2 4 6 6.3.1 Mathematical operations with matrices Using +,-,*,/ with two matrices performs element-wise addition, subtraction, multiplication, and division. y &lt;- x &lt;- matrix(1:6,2,3,byrow=TRUE) x + y # matrix addition (element-by-element) ## [,1] [,2] [,3] ## [1,] 2 4 6 ## [2,] 8 10 12 x - y # matrix subtraction (element-by-element) ## [,1] [,2] [,3] ## [1,] 0 0 0 ## [2,] 0 0 0 x*y # element-wise multiplication ## [,1] [,2] [,3] ## [1,] 1 4 9 ## [2,] 16 25 36 Note that A*B does not perform true matrix multiplication of matrices A and B. Matrix multiplication is done with %*% x %*% t(y) # (2x3) x (3x2) matrix ## [,1] [,2] ## [1,] 14 32 ## [2,] 32 77 t(x) %*% y # (3x2) x (2x3) matrix ## [,1] [,2] [,3] ## [1,] 17 22 27 ## [2,] 22 29 36 ## [3,] 27 36 45 6.4 Matrix Functionals 6.4.1 Functions applied to each row/column We can take the sum or mean of each row/column of a matrix by using either rowSums, rowMeans, colSums, or colMeans. A ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 rowSums(A) ## [1] 9 12 colSums(A) ## [1] 3 7 11 rowMeans(A) ## [1] 3 4 While rowSums works perfectly fine, let’s try writing our own rowSums() function: myRowSums &lt;-function(x){ ret &lt;- rep(NA,nrow(x)) ## make an empty vector for(i in 1:nrow(x)) { ret[i] &lt;-sum(x[i,]) ## take the sum of i-th row } return (ret) } rowSums(A) ## [1] 9 12 myRowSums(A) ## [1] 9 12 The implementation by the function myRowSums works fine. However, it is a bit cumbersome to write such a function whenever we want to compute column-wise/row-wise summary statistics. It would be nice if there were a quick &amp; general way to do the following: For each row or column of a matrix … Evaluate a function using the row/column vector as input Return the collection of results as a numeric vector. 6.4.2 apply(): dimension-wise aggregation rowSums(A) ## original row-wise sum ## [1] 9 12 apply(A, 1, sum) ## this also performs row-wise sum ## [1] 9 12 colSums(A) ## original column-wise sum ## [1] 3 7 11 apply(A, 2, sum) ## this also performs column-wise sum ## [1] 3 7 11 First parameter of apply: the input matrix. Second parameter of apply: the dimension over which to aggregate 1:rows, 2:columns Third parameter of apply: function to evaluate for each row/column A ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 apply(A, 1, sum) # row sums ## [1] 9 12 apply(A, 2, sum) # column sums ## [1] 3 7 11 Examples of using apply: colMeans(A) ## original columnw-wise mean ## [1] 1.5 3.5 5.5 apply(A, 2, mean) ## same as above ## [1] 1.5 3.5 5.5 # colMax(A) ## This will cause ERROR. colmax() does not exist! apply(A, 2, max) ## But this works! ## [1] 2 4 6 6.4.3 Using apply with your own function Suppose that instead of simply taking the row-wise or column-wise means we want to do the following: For each row/column: Calculate the squared sum of each row/column. Return the vector of squared sums. How can we do this using apply()? A big advantage of the apply function is the flexibility it gives you. You can use your own functions to compute row-wise/column-wise summary measures for certain measures that may not be implemented in base R. ## define a function named sqsum sqsum &lt;- function(x) { return( sum(x*x) ) ## very simple implementation } apply(A, 1, sqsum) ## run sqsum() funciton ## [1] 35 56 You can actually write the function definition inside of the apply function. This can be convenient when using straightforward functions that can be written on a single line: apply(A, 1, function(x) {return (sum(x*x))} ) ## much simpler! ## [1] 35 56 Or, we can write the above apply statement in an even simpler form: ## You can omit return() and {} especially ## for simple function definitions apply(A, 1, function(x) sum(x*x) ) ## Even simpler! ## [1] 35 56 apply() can also return a matrix ## if apply() returns a vector, each row stores results apply(A, 1, function(x) c(min(x),max(x)) ) ## [,1] [,2] ## [1,] 1 2 ## [2,] 5 6 apply(A, 2, function(x) c(min(x),max(x)) ) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 6.5 Exercises Write a function that has two input arguments A and B A and B are both matrices with the same dimension (same number of rows and columns). The function returns a matrix D. The [i,j] element of D should equal A[i,j] if A[i,j] &lt; B[i,j] and equal B[i,j] if A[i,j] &gt;= B[i,j]. You can use either a nested for loop or logical indexing. Suppose we define the matrix X as X &lt;- rbind( rep(c(1,4), each=3), rep(c(8,6), each=3)) What will be the value of apply(X, 2, sum)[2]? Write a function called PairwiseMedianDiffs that has two numeric matrices A and B as the input arguments. These two input matrices are assumed to have the same dimensions. This function should return a \\(p \\times p\\) matrix (where \\(p\\) is the number of columns in A). The [i,j] element of the returned matrix should equal the median of the \\(i^{th}\\) column of A minus the median of the \\(j^{th}\\) column of B. "],["list.html", "Chapter 7 Lists 7.1 Creating Lists in R 7.2 Accessing list elements 7.3 Working with lists 7.4 When are lists useful? 7.5 lapply() and sapply(): Applying functions to lists 7.6 Exercises", " Chapter 7 Lists R always store data as a “collection”. Dimension Homogeneous Heterogeneous 1-Dimension Atomic Vector List 2-Dimension Matrix Data Frame &gt;2-Dimensions Multi-dimensional array There is no “0-dimensional data” in R. Even a single-valued object is considered to be a “vector” with length 1. Source: http://adv-r.had.co.nz/Data-structures.html 7.1 Creating Lists in R Lists can store a collection of items that have different types. To create a list, you can use the list function. ## Use a keyword argument to define any attribute of any data type emp_info &lt;- list(name=&quot;Nicholas Henderson&quot;, UMID=12345678, faculty=TRUE) emp_info # list has character, numeric, and logical types ## $name ## [1] &quot;Nicholas Henderson&quot; ## ## $UMID ## [1] 12345678 ## ## $faculty ## [1] TRUE emp_info$name # access components with $component_name ## [1] &quot;Nicholas Henderson&quot; Create a list with named components: a, b, and d. list(a=c(1,2,3), b=c(&quot;apple&quot;,&quot;banana&quot;), d=TRUE) ## list elements can be vectors ## $a ## [1] 1 2 3 ## ## $b ## [1] &quot;apple&quot; &quot;banana&quot; ## ## $d ## [1] TRUE 7.2 Accessing list elements You can create named lists or unnamed lists. In an unnamed list, the list components do not have names. You can access the \\(k^{th}\\) element of an unnamed list using the double bracket syntax [[k]]. You can access the elements of a named list using either the indexing [[k]] or the component names. # Create an unnamed list and look at the first element: y &lt;- list(c(1,2,3), c(&quot;apple&quot;,&quot;banana&quot;), TRUE) y[[1]] ## [1] 1 2 3 Accessing the elements of a named list using either the numeric index or the component names: x &lt;- list(a=c(1,2,3), b=c(&quot;apple&quot;, &quot;banana&quot;), d=TRUE) x$a ## [1] 1 2 3 x[[1]] ## [1] 1 2 3 x$b ## [1] &quot;apple&quot; &quot;banana&quot; x[[2]] ## [1] &quot;apple&quot; &quot;banana&quot; 7.3 Working with lists Get the names of the list components by using names(list_name) names(x) ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; Find the length of a list by using length. Note that the length of a list is the number of components of the list, and the length does not depend on the length of any of the vector components. length(x) ## [1] 3 7.3.1 Expanding a list: adding more components Add components to a list using either the index or by name x ## $a ## [1] 1 2 3 ## ## $b ## [1] &quot;apple&quot; &quot;banana&quot; ## ## $d ## [1] TRUE x[[4]] &lt;- 4 x$e &lt;- 5 x ## $a ## [1] 1 2 3 ## ## $b ## [1] &quot;apple&quot; &quot;banana&quot; ## ## $d ## [1] TRUE ## ## [[4]] ## [1] 4 ## ## $e ## [1] 5 7.4 When are lists useful? Many R functions return multiple items as output. It is common to return these multiple items in a single, named list. matrixSum &lt;- function(X) { # calculate possible sums of a matrix s1 &lt;- rowSums(X) s2 &lt;- colSums(X) s3 &lt;- sum(X) return(list(row=s1, col=s2, all=s3)) ## return multiple values ## using a list } A &lt;- matrix(1:6,2,3) matrixSum(A) ## $row ## [1] 9 12 ## ## $col ## [1] 3 7 11 ## ## $all ## [1] 21 Lists are useful in situations where you have a collection of items of different types and dimensions that you want to store in a single “variable”. For example, you may have data on several individuals where, for each individual, you have data stored in a vector, a matrix, and a data frame. 7.5 lapply() and sapply(): Applying functions to lists lapply (“list apply”) works like an apply() function for lists. lapply has two arguments: An input list. The name of the function to apply to each component of the list. lapply returns a list with the same number of components as the input list: r &lt;- matrixSum(A) # r is a list with 3 components. lapply(r, length) # compute the length of each component of r ## $row ## [1] 2 ## ## $col ## [1] 3 ## ## $all ## [1] 1 lapply(r, sum) # Compute sum of each component of r ## $row ## [1] 21 ## ## $col ## [1] 21 ## ## $all ## [1] 21 lapply(r, function(x) sum(x*x)) # Compute sum of squares for each component ## $row ## [1] 225 ## ## $col ## [1] 179 ## ## $all ## [1] 441 7.5.1 Use sapply() for simpler output When applying a function to each component of a list, it is often preferable to have the result returned as a vector or matrix instead of a list. This is what the sapply() (“simplified lapply”) function does. sapply(r, sum) # sapply() returns output as a named vector ## row col all ## 21 21 21 lapply(r,sum) ## $row ## [1] 21 ## ## $col ## [1] 21 ## ## $all ## [1] 21 If the function used in sapply returns a vector with length longer than 1, sapply will return a matrix. r ## $row ## [1] 9 12 ## ## $col ## [1] 3 7 11 ## ## $all ## [1] 21 ## column names of matrix are same sapply(r, function(x) c(min(x),max(x)) ) ## as list component names ## row col all ## [1,] 9 3 21 ## [2,] 12 11 21 7.6 Exercises Suppose we define the vector x as x &lt;- c(1,2,3). What is the value of length( list(x) ) == length(x) Write a function that takes a list called x as input, and the elements of x can be assumed to be numeric vectors. The function should return a matrix where the number of columns of the matrix equal the number of elements of the input list. the number of rowsof the matrix equals 4 If the \\(k^{th}\\) element of the list has length greater than 4, the \\(k^{th}\\) column of the output matrix should be (mean(x[[k]]), median(x[[k]]), min(x[[k]]), max(x[[k]])) If the \\(k^{th}\\) element of the list has length 4 or less, the \\(k^{th}\\) column of the output matrix should be (0, 0, 0, 0). "],["dataframe.html", "Chapter 8 Data Frames 8.1 Creating Data Frames 8.2 Accessing and Modifying Data Frames 8.3 Subsetting data frames 8.4 Exercises", " Chapter 8 Data Frames Dimension Homogeneous Heterogeneous 1-Dimension Atomic Vector List 2-Dimension Matrix Data Frame &gt;2-Dimensions Multi-dimensional array Data Frames are the most common tool for storing “rectangular” datasets (data stored as a table in rows and columns) in R. Each row holds an observation. Each column holds a variable. Roughly speaking, a data frame can be thought of as a matrix where different columns can hold different types of data. The elements in the same column of a data frame should have the same type. More technically, a data frame is actually a .red[list of vectors] that all have the same length. Number of variables = number of elements in list. Let’s first look at one of R’s built-in datasets to see an example of a data frame. R has many built-in datasets that are stored as data frames. Type in library(help = \"datasets\") to see the full list of built-in datasets. One of the built-in datasets is the PlantGrowth dataset. You can load this dataset into your R session by typing in data(PlantGrowth) Check that PlantGrowth is a data frame by using class(PlantGrowth) ## [1] &quot;data.frame&quot; You can display the first few rows of the PlantGrowth data by using head(): head( PlantGrowth ) ## weight group ## 1 4.17 ctrl ## 2 5.58 ctrl ## 3 5.18 ctrl ## 4 6.11 ctrl ## 5 4.50 ctrl ## 6 4.61 ctrl This dataset has 30 observations and 2 variables. This can be seen by applying dim() to the data frame: dim( PlantGrowth ) ## [1] 30 2 8.1 Creating Data Frames The main way to create a data frame in R is to use the function data.frame. To create a data frame with 5 observations and two variables named x and y: # x and y have to be the same length df &lt;- data.frame(x=c(1,2,3,4,5), y=c(1,4,9,16,25)) df ## x y ## 1 1 1 ## 2 2 4 ## 3 3 9 ## 4 4 16 ## 5 5 25 Converting a data frame to a matrix df.mat &lt;- as.matrix(df) ## How a Data Frame looks like df ## x y ## 1 1 1 ## 2 2 4 ## 3 3 9 ## 4 4 16 ## 5 5 25 df.mat ## How a matrix looks like ## x y ## [1,] 1 1 ## [2,] 2 4 ## [3,] 3 9 ## [4,] 4 16 ## [5,] 5 25 You can use as.data.frame to convert a matrix into a data frame. X &lt;- matrix(1:6,3,2) colnames(X) &lt;- c(&quot;a&quot;,&quot;b&quot;) X.df &lt;- as.data.frame(X) X ## a b ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 X.df ## a b ## 1 1 4 ## 2 2 5 ## 3 3 6 Remember that a data frame can take heterogeneous data types. df &lt;- data.frame(x=c(1,2,3),y=c(&quot;a&quot;,&quot;a&quot;,&quot;bc&quot;)) colnames(X) &lt;- c(&quot;a&quot;,&quot;b&quot;) X.df &lt;- as.data.frame(X) X ## a b ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 X.df ## a b ## 1 1 4 ## 2 2 5 ## 3 3 6 8.2 Accessing and Modifying Data Frames One way to access the individual elements of a data frame is by specifying the row/column index. This is done in exactly the same way as with a matrix. df[,1] ## access a column just like a matrix ## [1] 1 2 3 df[1:2,] ## access rows like matrix ## x y ## 1 1 a ## 2 2 a df[2, 1] ## access individual elements ## [1] 2 You can access the data from a specific variable by name using the syntax: df_name$var_name. df$y ## access a column by name ## [1] &quot;a&quot; &quot;a&quot; &quot;bc&quot; ## what happens if we omit a comma? df[1] ## (Remember that df is actually list) ## x ## 1 1 ## 2 2 ## 3 3 Differences in element access between matrices and data frames: df.mat &lt;- as.matrix(df) df[2] #df[10] will not work ## y ## 1 a ## 2 a ## 3 bc df.mat[2] ## [1] &quot;2&quot; df.mat[10] ## [1] NA Modifying data frames: df &lt;- data.frame(x=c(1,2,3),y=c(&quot;a&quot;,&quot;a&quot;,&quot;bc&quot;)) df$z = c(&quot;def&quot;,&quot;123&quot;,&quot;123&quot;) ## adding a new column df ## x y z ## 1 1 a def ## 2 2 a 123 ## 3 3 bc 123 df2 &lt;- data.frame(w=c(TRUE,FALSE,FALSE)) cbind(df,df2) # combine columns ## x y z w ## 1 1 a def TRUE ## 2 2 a 123 FALSE ## 3 3 bc 123 FALSE Adding new rows to a data frame: df3 &lt;- data.frame(x=4,y=&quot;a&quot;,z=&quot;def&quot;) rbind(df,df3) ## x y z ## 1 1 a def ## 2 2 a 123 ## 3 3 bc 123 ## 4 4 a def 8.3 Subsetting data frames df ## x y z ## 1 1 a def ## 2 2 a 123 ## 3 3 bc 123 subset(df, x&gt;1) ## x y z ## 2 2 a 123 ## 3 3 bc 123 subset(df, x&gt;1 &amp; y ==&quot;a&quot;) ## x y z ## 2 2 a 123 8.4 Exercises For this exercise, you will use the Loblolly dataset which is a built-in R dataset. You can load the Loblolly data frame and look at the first few rows with the following commands: data(Loblolly) head(Loblolly) In Loblolly, each different value of the variable Seed variable corresponds to a different tree. How many rows are in the Loblolly data frame? What is the mean and standard deviation of the age variable in Loblolly? How many of the values in the variable height are greater than \\(50\\) feet? What is the correlation between the height and age variables? (For this part, you can use the cor function) Add a variable called Seed.first to the Loblolly data frame. This variable should equal \\(1\\) at the first occurrence of a value of Seed and equal \\(0\\) if the value of Seed is already in a previous row of Loblolly. How many different trees (i.e., unique values of the Seed variable) are there in this data frame? Add another variable called obs.num to the Loblolly data frame. This variable should equal \\(1\\) the first time a value of Seed occurs, should equal \\(2\\) the second time a value of Seed occurs, etc. … Add another variable to Loblolly called height.change which measures the change in height from the earliest age of the tree to the latest age of the tree. After completing steps (a)-(h), the first 8 rows your modified Loblolly data frame should look like the following … Compute a vector which contains the “within-tree” correlations between height and age. The \\(k^{th}\\) element of this vector should contain the correlation between the height and age values from the \\(k^{th}\\) tree. "],["factors.html", "Chapter 9 Factors 9.1 Definition of Factors 9.2 Adding new levels to a factor 9.3 The table() function 9.4 tapply() and aggregate", " Chapter 9 Factors Factors in R were created to represent categorical variables in statistics. Categorical Variable: Categorical variables represent membership in some category rather than a numerical value (e.g., blood type, country, language spoken, treatment group). Categorical variables can only assume one of a finite collection values. It does not usually make sense to make numerical comparisons between categorical variables. 9.1 Definition of Factors In R, a factor can be thought of as a vector that contains specific extra information about that vector. More specifically, a factor is a vector that has certain attributes that distinguish from non-factor vectors. One key attribute stored by a factor vector is its levels. The levels of a factor vector determine the set of allowable values in that vector. For example, let’s look at the group variable in the PlantGrowth dataset data(PlantGrowth) PlantGrowth$group ## [1] ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl ctrl trt1 trt1 trt1 trt1 trt1 ## [16] trt1 trt1 trt1 trt1 trt1 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 trt2 ## Levels: ctrl trt1 trt2 The group variable is a factor with the following 3 levels: ctrl, trt1, trt2. It is appropriate to make the group variable in PlantGrowth a factor since this variable represents the treatment condition in this study. Because the levels of group (ctrl, trt1, trt2) represent the collection of possible values, you cannot assign the elements of PlantGrowth$group a value which is not either ctrl, trt1, or trt2. PlantGrowth$group[4] &lt;- &quot;trt&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 4, value = structure(c(1L, 1L, 1L, NA, : ## invalid factor level, NA generated Assigning the 5th element the value \"trt1\" works though: PlantGrowth$group[5] &lt;- &quot;trt1&quot; The other main attribute which distinguishes factors is its class. attr(PlantGrowth$group, &quot;class&quot;) # Check the class attribute ## [1] &quot;factor&quot; If the class of a vector is a factor, numerical comparisons between elements will return an error: PlantGrowth$group[5] &gt; PlantGrowth$group[15] ## Warning in Ops.factor(PlantGrowth$group[5], PlantGrowth$group[15]): &#39;&gt;&#39; not ## meaningful for factors ## [1] NA PlantGrowth$group[5] + PlantGrowth$group[15] # This returns an error ## Warning in Ops.factor(PlantGrowth$group[5], PlantGrowth$group[15]): &#39;+&#39; not ## meaningful for factors ## [1] NA 9.2 Adding new levels to a factor In some cases, you want to add data to a factor vector, and the new data contains new categories which are not in the original factor vector. To do this, you can assign new levels to your factor vector by using the assignment: `levels(vec_name) &lt;- ` For example, look what happens when we try to change the value of one element from a factor vector y &lt;- factor(rep(1:3, 3)) # create factor with levels 1, 2, 3 y[3] &lt;- 4 # Try to assign 3rd element the value 4 ## Warning in `[&lt;-.factor`(`*tmp*`, 3, value = 4): invalid factor level, NA ## generated y # Note that the third element is now NA ## [1] 1 2 &lt;NA&gt; 1 2 3 1 2 3 ## Levels: 1 2 3 We can add the value \\(4\\) to this vector, but we need to change the factor levels first: levels(y) &lt;- c(1,2,3,4) y[3] &lt;- 4 y ## [1] 1 2 4 1 2 3 1 2 3 ## Levels: 1 2 3 4 The str() function gives a description of any R object. For a data frame, you can see which variables are treated as factors and which are treated as numeric str( PlantGrowth ) ## &#39;data.frame&#39;: 30 obs. of 2 variables: ## $ weight: num 4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ... ## $ group : Factor w/ 3 levels &quot;ctrl&quot;,&quot;trt1&quot;,..: 1 1 1 NA 2 1 1 1 1 1 ... 9.3 The table() function The table() function can be used to count the number of observations at each level of a factor. table() can also be used to count the number of observations ocurring at each .level combination for 2 or more factors. For example, let’s count the number of observations in each treatment group in the PlantGrowth data: table( PlantGrowth$group ) # 10 observations in each group ## ## ctrl trt1 trt2 ## 10 10 10 To see how table works for multiple factors, let’s look at the VA dataset from the MASS package library(MASS) data(VA) # load the VA data frame str(VA) # look at the structure of this data frame ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ stime : num 72 411 228 126 118 10 82 110 314 100 ... ## $ status : num 1 1 1 1 1 1 1 1 1 0 ... ## $ treat : Factor w/ 2 levels &quot;1&quot;,&quot;2&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ age : num 69 64 38 63 65 49 69 68 43 70 ... ## $ Karn : num 60 70 60 60 70 20 40 80 50 70 ... ## $ diag.time: num 7 5 3 9 11 5 10 29 18 6 ... ## $ cell : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ prior : Factor w/ 2 levels &quot;0&quot;,&quot;10&quot;: 1 2 1 2 2 1 2 1 1 1 ... Notice that the variables treat and cell are factors in the VA data frame. You can cross-tabulate these two factors by using plugging both variables into the table function. tab.VA &lt;- table(VA$treat, VA$cell) tab.VA ## ## 1 2 3 4 ## 1 15 30 9 15 ## 2 20 18 18 12 tab.VA is an example of what’s usually called a 2x4 contingency table. You can compute the table margins as if tab.VA were a matrix colSums(tab.VA) ## 1 2 3 4 ## 35 48 27 27 You are not limited to cross-tabulating two factor variables. For example, we can cross-tabulate the factors treat, cell, and prior: table(VA$treat, VA$cell, VA$prior) ## , , = 0 ## ## ## 1 2 3 4 ## 1 8 23 7 10 ## 2 13 14 15 7 ## ## , , = 10 ## ## ## 1 2 3 4 ## 1 7 7 2 5 ## 2 7 4 3 5 This outputs two 2x4 contingency tables: A contingency table of treat and cell for each level of prior. 9.4 tapply() and aggregate tapply() is useful when you want to compute certain summary statistics for each level of a factor variable. For example, suppose we wanted to compute the mean and standard deviation of age in the VA data within each treatment group. This can be done with the following code: tapply(VA$age, VA$treat, mean) # compute mean age in each trt. group ## 1 2 ## 57.50725 59.11765 tapply(VA$age, VA$treat, sd) # compute sd of age in each trt. group ## 1 2 ## 10.81070 10.27754 You can use the aggregate() function to use tapply() across multiple variables. This is useful, for example, if you want to compute the mean of each of the numeric variables in a data frame using a single command. Note that the variables stime, status, age, Karn, diag.time in the VA data are numeric: str(VA) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ stime : num 72 411 228 126 118 10 82 110 314 100 ... ## $ status : num 1 1 1 1 1 1 1 1 1 0 ... ## $ treat : Factor w/ 2 levels &quot;1&quot;,&quot;2&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ age : num 69 64 38 63 65 49 69 68 43 70 ... ## $ Karn : num 60 70 60 60 70 20 40 80 50 70 ... ## $ diag.time: num 7 5 3 9 11 5 10 29 18 6 ... ## $ cell : Factor w/ 4 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ prior : Factor w/ 2 levels &quot;0&quot;,&quot;10&quot;: 1 2 1 2 2 1 2 1 1 1 ... We can compute the mean of each of the numeric variables in VA, stratified by cell type, by using aggregate() in the following way: # Use aggregate on VA only using 1st, 2nd, 4th, 5th, 6th variables aggregate(VA[,c(1,2,4,5,6)], list(VA$cell), mean) ## Group.1 stime status age Karn diag.time ## 1 1 200.20000 0.8857143 58.45714 60.85714 11.028571 ## 2 2 71.66667 0.9375000 59.87500 53.54167 9.250000 ## 3 3 64.11111 0.9629630 57.40741 58.11111 5.629630 ## 4 4 166.11111 0.9629630 56.22222 65.00000 8.148148 Compute the median of each of the variables stratified by cell type aggregate(VA[,c(1,2,4,5,6)], list(VA$cell), median) ## Group.1 stime status age Karn diag.time ## 1 1 111 1 62.0 60 7 ## 2 2 51 1 62.5 60 4 ## 3 3 51 1 61.0 60 4 ## 4 4 156 1 62.0 70 8 "],["fileinput.html", "Chapter 10 Reading Data Files into R 10.1 Downloading a file locally 10.2 Opening a remote file using read.table()", " Chapter 10 Reading Data Files into R Text files Files with human readable characters such as letters, numbers, special characters (e.g., .red[“, ’, ?]), typically composed of multiple lines. Can represent different characters by text encodings There are many types of text files, e.g., -R files (.R) -html files (.html) / cascading style sheet (.css) -text files (.txt) 10.1 Downloading a file locally Need to download a file to your local computer To test out reading in datasets into R that you have stored locally on your computer, we will first download the gapminder dataset. When you download a file, make sure you know which folder it is in and that you can find the file path for the downloaded file. To load the gapminder dataset into R, you can use the read.csv function. Before running read.csv, it is often convenient to first set the working directory in R first using setwd This allows you to load in all the files from the folder containing your data files without typing in the full file path name every time For example, if the gapminder data was stored in a folder with path “~/IntrotoR/Data, we could first type setwd(&quot;~/IntrotoR/Data&quot;) After running setwd, we can now load in the gapminder dataset (stored as gapminder_full.csv on my computer) using read.csv fname &lt;- &quot;gapminder_full.csv&quot; gapminder &lt;- read.csv(fname) To import a .csv file (or any other text file) in Rstudio, you can also click on the Import Dataset button on the top right panel. This lets you view how the data would appear before it is loaded into R. The read.table() function is the more general function for reading in rectangular data stored in text files. You can read in other types of text files: e.g., .tsv, .txt read.table() can do the same thing as read.csv(). The main difference is that the default settings of read.csv() are setup to handle .csv files nicely. For example, we could read in the gapminder data with read.table() using: df &lt;- read.table(fname, header=TRUE, sep=&quot;,&quot;) # Set header=TRUE head(df) ## country year population continent life_exp gdp_cap ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 You can look at the first few rows of a loaded data frame using head: dim(gapminder) # 1704 observations, 6 variables ## [1] 1704 6 head(gapminder, 8) ## look at first 8 rows ## country year population continent life_exp gdp_cap ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 ## 7 Afghanistan 1982 12881816 Asia 39.854 978.0114 ## 8 Afghanistan 1987 13867957 Asia 40.822 852.3959 gapminder$country[1:5] # note that country is a factor ## [1] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; Looking at the structure of the data frame using str() str( gapminder ) ## &#39;data.frame&#39;: 1704 obs. of 6 variables: ## $ country : chr &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ... ## $ year : int 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... ## $ population: int 8425333 9240934 10267083 11537966 13079460 14880372 12881816 13867957 16317921 22227415 ... ## $ continent : chr &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; ... ## $ life_exp : num 28.8 30.3 32 34 36.1 ... ## $ gdp_cap : num 779 821 853 836 740 ... Reading strings as non-factors: gapminder_nofac &lt;- read.csv(fname, stringsAsFactors = FALSE) head(gapminder_nofac) ## country year population continent life_exp gdp_cap ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 gapminder_nofac$country[1:5] # No more &quot;levels&quot; ## [1] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; You can skip lines when you read in a text file. This is useful if you don’t want to read in the “header” line of the .csv file: df &lt;- read.table(fname, header=FALSE, sep=&quot;,&quot;,skip=1) head(df) ## V1 V2 V3 V4 V5 V6 ## 1 Afghanistan 1952 8425333 Asia 28.801 779.4453 ## 2 Afghanistan 1957 9240934 Asia 30.332 820.8530 ## 3 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 4 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 5 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 6 Afghanistan 1977 14880372 Asia 38.438 786.1134 Or, skip the header and the first two rows of the .csv file df &lt;- read.table(fname, header=FALSE, sep=&quot;,&quot;,skip=3) head(df) ## V1 V2 V3 V4 V5 V6 ## 1 Afghanistan 1962 10267083 Asia 31.997 853.1007 ## 2 Afghanistan 1967 11537966 Asia 34.020 836.1971 ## 3 Afghanistan 1972 13079460 Asia 36.088 739.9811 ## 4 Afghanistan 1977 14880372 Asia 38.438 786.1134 ## 5 Afghanistan 1982 12881816 Asia 39.854 978.0114 ## 6 Afghanistan 1987 13867957 Asia 40.822 852.3959 10.2 Opening a remote file using read.table() You can read in a dataset directly from a URL: # Read in ignoring the fact that there is a header line urlname &lt;- paste(&quot;https://web.stanford.edu/~hastie/&quot;, &quot;ElemStatLearn/datasets/bone.data&quot;, sep=&quot;&quot;) bone_dat &lt;- read.table(urlname) head(bone_dat, 4) ## V1 V2 V3 V4 ## 1 idnum age gender spnbmd ## 2 1 11.7 male 0.01808067 ## 3 1 12.7 male 0.06010929 ## 4 1 13.75 male 0.005857545 # Set header=TRUE to read in top line as the variable names bone_dat2 &lt;- read.table(urlname, header=TRUE) head(bone_dat2, 4) ## idnum age gender spnbmd ## 1 1 11.70 male 0.018080670 ## 2 1 12.70 male 0.060109290 ## 3 1 13.75 male 0.005857545 ## 4 2 13.25 male 0.010263930 "],["datawrangling.html", "Chapter 11 Data Wrangling 11.1 The nycflights13 data 11.2 Exploring the Dataset", " Chapter 11 Data Wrangling Data Wrangling just refers to the process of organizing your data into a useful format so that you can Perform the statistical analysis you are interested in. Produce the data visualizations you are interested in. The amount of work involved in the data wrangling process will vary a lot depending on how “clean” the original dataset is. Examples of steps involved in data wrangling: subsetting data, merging data, transforming data, deriving new variables, handling missing data 11.1 The nycflights13 data To illustrate the techniques described in this chapter, we will use the “NYC Flights Dataset” available from the nycflights13 R package. To load this package into R, first install the nycflights13 and then load it into R with the following command: library(nycflights13) This package has several datasets available. We will explore the flights dataset in this chapter. This dataset can be loaded into R with the following command. data(flights) tibble vs. data frame here. flights &lt;- as.data.frame( flights ) 11.2 Exploring the Dataset The first thing you usually want to note about a dataset after first loading it is how many observations and variables there are. While you can note the dimensions of your data under the “Environment” tab in Rstudio, you can see this by using dim dim(flights) ## [1] 336776 19 This data frame has \\(336,776\\) observations and \\(19\\) variables. To see what is stored in the first few rows of flights use head: head(flights) ## year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time ## 1 2013 1 1 517 515 2 830 819 ## 2 2013 1 1 533 529 4 850 830 ## 3 2013 1 1 542 540 2 923 850 ## 4 2013 1 1 544 545 -1 1004 1022 ## 5 2013 1 1 554 600 -6 812 837 ## 6 2013 1 1 554 558 -4 740 728 ## arr_delay carrier flight tailnum origin dest air_time distance hour minute ## 1 11 UA 1545 N14228 EWR IAH 227 1400 5 15 ## 2 20 UA 1714 N24211 LGA IAH 227 1416 5 29 ## 3 33 AA 1141 N619AA JFK MIA 160 1089 5 40 ## 4 -18 B6 725 N804JB JFK BQN 183 1576 5 45 ## 5 -25 DL 461 N668DN LGA ATL 116 762 6 0 ## 6 12 UA 1696 N39463 EWR ORD 150 719 5 58 ## time_hour ## 1 2013-01-01 05:00:00 ## 2 2013-01-01 05:00:00 ## 3 2013-01-01 05:00:00 ## 4 2013-01-01 05:00:00 ## 5 2013-01-01 06:00:00 ## 6 2013-01-01 05:00:00 Each row of flights holds information related to a single flight that departed from the New York City area in 2013. The carrier variable in flights contains the abbreviation for the airline carrier. We can see that there are 16 different carriers in this dataset by using unique: length( unique(flights$carrier) ) ## 16 unique carriers ## [1] 16 Each plane has a unique tail number. Using unique, we can see that there are \\(4044\\) unique planes represented in the flights dataset length( unique(flights$tailnum) ) ## [1] 4044 Using table, we can see which carriers had the most flights out of the New York City area: table( flights$carrier ) ## ## 9E AA AS B6 DL EV F9 FL HA MQ OO UA US ## 18460 32729 714 54635 48110 54173 685 3260 342 26397 32 58665 20536 ## VX WN YV ## 5162 12275 601 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
